---
layout: cyber-post
title: "My personal NAS!"
description: "Costruire un Cloud personale sicuro e indipendente con Raspberry Pi"
date: 2025-10-19
categories: Projects
image: /images/1.png
---

My own home NAS setup.

---

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BL2501MC35"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-BL2501MC35');
</script>

<!-- Star Repository Alert -->
<div id="star-alert" class="star-alert">
  <div class="star-alert-content">
    <span class="star-icon">‚≠ê</span>
    <span class="star-text">Ti piace il sito?</span>
    <br>
    <span class="star-text">Lascia una stella su GitHub!</span>
    <br>
    <a href="https://github.com/Chris1sFlaggin/Chris1sFlaggin.github.io" target="_blank" class="star-button">
      ‚≠ê Stella
    </a>
    <button id="close-star-alert" class="close-button">&times;</button>
  </div>
</div>

<div id="like-system" style="text-align: center; padding: 15px; border: none; border-radius: 10px;">
  <button id="like-btn" style="background: none; border: none; font-size: 2em; cursor: pointer; transition: all 0.3s ease;">
    <span id="flame-icon">üî•</span>
  </button>
  <div id="like-count" style="margin-top: 10px; font-weight: bold; color: #fff;">
    <span id="count-number">...</span> fiamme
  </div>
</div>

<script>
(function() {
  // 1. INCOLLA L'URL DELLA TUA APP WEB GOOGLE SCRIPT QUI
  const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwh81aSmkikv6bzHSjCMF-_CxnJ7ef9RX03qoKiTjnwzWWWz3pChiY_g847SetxQDfu/exec';
  
  // Usiamo un ID per questo post, puoi cambiarlo per altre pagine
  const POST_ID = 'mio-primo-post'; 
  const LIKED_KEY = `nas-post-liked-${POST_ID}`;
  
  const likeBtn = document.getElementById('like-btn');
  const flameIcon = document.getElementById('flame-icon');
  const countNumber = document.getElementById('count-number');
  
  // Stato locale dell'utente
  let hasLiked = localStorage.getItem(LIKED_KEY) === 'true';
  // Stato globale (caricato dallo script)
  let globalLikes = 0;
  
  function updateUI() {
    countNumber.textContent = globalLikes;
    
    if (hasLiked) {
      flameIcon.style.transform = 'scale(1.3)';
      flameIcon.style.filter = 'drop-shadow(0 0 8px orange)';
      likeBtn.style.background = '#ff6b35'; 
      likeBtn.style.borderRadius = '50%';
      likeBtn.style.padding = '10px';
    } else {
      flameIcon.style.transform = 'scale(1)';
      flameIcon.style.filter = 'grayscale(50%)';
      likeBtn.style.background = 'none';
      likeBtn.style.padding = '5px';
    }
  }
  
  // Funzione per chiamare il nostro Google Script
  async function callLikeScript(action) {
    // Aggiungiamo '?' e l'azione, e un parametro 't' per evitare la cache
    const url = `${SCRIPT_URL}?action=${action}&t=${new Date().getTime()}`;
    
    try {
      const response = await fetch(url);
      if (!response.ok) { throw new Error('Errore di rete'); }
      
      const data = await response.json();
      globalLikes = data.count; // Aggiorna il conteggio globale
      updateUI(); // Aggiorna la UI con il nuovo numero
      
    } catch (error) {
      console.error('Errore nel chiamare lo script:', error);
      // Anche se c'√® un errore, aggiorniamo la UI locale
      updateUI();
    }
  }

  function toggleLike() {
    // Disabilita il pulsante per evitare click doppi
    likeBtn.disabled = true; 
    
    let action = '';
    
    if (hasLiked) {
      // Rimuovi like
      hasLiked = false;
      action = 'remove';
      flameIcon.style.animation = 'shake 0.5s ease-in-out';
    } else {
      // Aggiungi like
      hasLiked = true;
      action = 'add';
      flameIcon.style.animation = 'bounce 0.6s ease-in-out';
      createFireParticles();
    }
    
    // Salva stato locale
    localStorage.setItem(LIKED_KEY, hasLiked.toString());
    
    // Chiama lo script per aggiornare il conteggio globale
    // e riabilita il pulsante dopo che ha finito
    callLikeScript(action).finally(() => {
      likeBtn.disabled = false;
    });
    
    // Reset animazione
    setTimeout(() => {
      flameIcon.style.animation = '';
    }, 600);
  }
  
  // Carica il conteggio iniziale all'avvio della pagina
  function loadInitialCount() {
    callLikeScript('get'); // 'get' prende solo il valore senza modificarlo
  }
  
  // Funzione createFireParticles
  function createFireParticles() {
    const rect = likeBtn.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    for (let i = 0; i < 6; i++) {
      const particle = document.createElement('div');
      particle.textContent = ['üî•', '‚ú®', 'üí•'][Math.floor(Math.random() * 3)];
      particle.style.position = 'fixed';
      particle.style.left = centerX + 'px';
      particle.style.top = centerY + 'px';
      particle.style.fontSize = '1em';
      particle.style.pointerEvents = 'none';
      particle.style.zIndex = '9999';
      particle.style.animation = `particle-${i} 1s ease-out forwards`;
      document.body.appendChild(particle);
      setTimeout(() => particle.remove(), 1000);
    }
  }
  
  // Event listener
  likeBtn.addEventListener('click', toggleLike);
  
  // CSS animazioni (COMPLETATO)
  const style = document.createElement('style');
  style.textContent = `
    @keyframes bounce {
      0% { transform: scale(1); }
      50% { transform: scale(1.5); }
      100% { transform: scale(1.3); }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0) scale(1.3); }
      25% { transform: translateX(-5px) scale(1.1); }
      75% { transform: translateX(5px) scale(1.1); }
    }
    
    @keyframes particle-0 {
      to { transform: translate(-30px, -30px); opacity: 0; }
    }
    @keyframes particle-1 {
      to { transform: translate(30px, -30px); opacity: 0; }
    }
    @keyframes particle-2 {
      to { transform: translate(-20px, -40px); opacity: 0; }
    }
    @keyframes particle-3 {
      to { transform: translate(20px, -40px); opacity: 0; }
    }
    @keyframes particle-4 {
      to { transform: translate(0px, -50px); opacity: 0; }
    }
    @keyframes particle-5 {
      to { transform: translate(-10px, -35px); opacity: 0; }
    }
    
    #like-btn:hover {
      transform: scale(1.1);
    }
  `;
  document.head.appendChild(style);
  
  // Avvia tutto caricando il conteggio iniziale
  loadInitialCount();
})();
</script>

---

# Il progetto

> video generato con VEO3
<video width="100%" controls>
  <source src="/images/nas.mp4" type="video/mp4">
  Il tuo browser non supporta il tag video.
</video>

## Lo schema

> immagine generata con nano banana
![Schema](/images/schema.png)

## L‚Äôintuizione

L‚Äôaltro giorno ero in universit√†. Tra una lezione in cui la concentrazione era ormai un miraggio e un‚Äôaltra che sembrava non finire mai, mi √® venuta un‚Äôidea:
**‚ÄúPerch√© non ho una [NAS](https://it.wikipedia.org/wiki/Network_Attached_Storage) in casa?\!‚Äù**.

Cos√¨, mentre cercavo di sembrare ancora minimamente attento, ho iniziato a pensare a cosa potrei farci. La prima idea √® stata un [***proxy cache***](https://www.google.com/search?q=https://it.wikipedia.org/wiki/Proxy%23Caching_proxy_server) ‚Äî ottimo progetto, e sicuramente lo realizzer√≤ in futuro ‚Äî ma non era quello che cercavo in quel momento.

Volevo qualcosa di **pratico ed esteticamente bello da tenere in camera**, qualcosa che potesse servire **anche ai miei genitori**, non solo a me e alle mie sperimentazioni tecniche.

-----

## L‚Äôidea

Dopo qualche minuto di *brainstorming*, ho buttato gi√π due direzioni principali:

  * ‚òÅÔ∏è **Un *cloud* personale** con [Immich](https://immich.app)
    Perfetto per gestire foto e video di famiglia, accessibile da qualsiasi dispositivo e con il controllo totale dei dati.
    Niente pi√π dipendenza da Google Photos o iCloud ‚Äî tutto in casa, tutto sotto il mio *NAS*.

  * üîÅ **Un [*reverse proxy*](https://it.wikipedia.org/wiki/Reverse_proxy)** per accedere a contenuti limitati sulle ***smart TV***. (_Vi lascio immaginare quali_).

-----

## Componenti

>(clicca sull'immagine per ottenere link)

### Raspberry Pi 3b

[![Raspberry Pi 3b](https://m.media-amazon.com/images/I/91zSu44+34L.jpg)](https://www.amazon.it/Raspberry-PI-Model-Scheda-madre/dp/B01CD5VC92)

### Custodia

[![3.5" Screen Case](https://m.media-amazon.com/images/I/61VWMWUQ-pL._AC_UF1000,1000_QL80_.jpg)](https://www.amazon.it/-/en/Raspberry-Supports-Raspbian-RetroPie-Multi-System/dp/B07NTH1JWH)

### Raidbox

[![Raidbox](https://m.media-amazon.com/images/I/61jotZv7FIL._AC_SL1500_.jpg)](https://www.amazon.it/-/en/RAID-CENMATE-Bay-Supports-Capacity/dp/B0DCZB849Y)

-----

## SetUp

### 1\. SetUp reverse proxy

Prima di iniziare, chiariamo cosa stiamo facendo. Per creare il nostro *reverse proxy*, installeremo due componenti software fondamentali: **Squid** e **Nginx**. In questa configurazione:

  * [**Nginx**](https://it.wikipedia.org/wiki/Nginx) (pronunciato *engine-x*) √® un *web server* ad alte prestazioni che useremo come [*reverse proxy*](https://www.cloudflare.com/it-it/learning/cdn/glossary/reverse-proxy/). Sar√† lui a ricevere le richieste dalla *smart TV* e a inoltrarle ai servizi di destinazione corretti.
  * [**Squid**](https://it.wikipedia.org/wiki/Squid) √® un [*proxy server*](https://www.fortinet.com/it/resources/cyberglossary/proxy-server) molto potente e versatile. In questo progetto lo useremo per la sua capacit√† di intercettare e modificare al volo le richieste e le risposte, ad esempio cambiando gli [*header HTTP*](https://www.google.com/search?q=https://developer.mozilla.org/it/docs/Web/HTTP/Headers). Questo √® il "trucco" che ci permetter√† di accedere ai contenuti desiderati.

#### 1.1. Squid

SSH sul raspberry e digita i seguenti comandi per installare *Squid*.

```bash
# installa squid
sudo apt install squid -y
# backup file conf
sudo mv /etc/squid/squid.conf /etc/squid/squid.conf.bak
# modifica file conf
sudo nano /etc/squid/squid.conf
```

Vi lascio il link al mio file funzionante:
[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/proxyConf/squid.conf)

```bash
# applica le modifiche e controlla lo stato
sudo systemctl restart squid
sudo systemctl enable squid
sudo systemctl status squid
```

> Verifica che lo stato sia Active: active (running).

#### 1.2. Nginx

```bash
# installa nginx
sudo apt install nginx -y
# rimuovi file conf default
sudo rm -f /etc/nginx/sites-enabled/default
# crea nuovo file conf
sudo nano /etc/nginx/sites-available/tv-proxy
```

Anche qui lascio il link al mio file funzionante:
[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/proxyConf/tv-proxy)

```bash
# crea un symlink dal tuo file di configurazione al directory sites-enabled.
sudo ln -s /etc/nginx/sites-available/tv-proxy /etc/nginx/sites-enabled/
# verifica la sintassi del tuo file conf
sudo nginx -t
```

```bash
# applica le modifiche
sudo systemctl restart nginx
sudo systemctl enable nginx
sudo systemctl status nginx
```

> Verifica che lo stato sia Active: active (running).

### 2\. SetUp immich

#### 2.1. Download immich

Per la memoria io ho montato un *raidbox*. Torneremo pi√π tardi sul perch√®.
Dopo averlo montato passiamo al prossimo passaggio.

##### Una nota su Docker

A differenza di Squid e Nginx, Immich non si installa "direttamente" sul sistema operativo. Invece, utilizza [**Docker**](https://www.google.com/search?q=https://it.wikipedia.org/wiki/Docker_\(informatica\)).

Pensa a *Docker* come a un sistema per impacchettare un'applicazione (come Immich) e tutte le sue dipendenze (database, librerie, ecc.) in una "scatola" autonoma e isolata, chiamata ***container***. Questo rende l'installazione e la gestione molto pi√π semplici, perch√© l'applicazione vive in un ambiente controllato senza "sporcare" il sistema principale (salvo malfunzionamenti vari dati da troppi container attivi, ma non fa il nostro caso).

Per gestire i vari servizi che compongono Immich, useremo [**Docker Compose**](https://docs.docker.com/compose/), uno strumento che legge un singolo file di configurazione per avviare e collegare tra loro pi√π *container* contemporaneamente.

**Importante:** Far girare *Docker* (e in particolare un'applicazione complessa come Immich) su un **Raspberry Pi 3b**, che ha risorse limitate (specialmente *RAM*), √® **prestazionalmente costoso**. L'avvio dei *container* potrebbe essere lento e le prestazioni generali del *NAS* potrebbero risentirne. √à una sfida, ma come vedremo, √® fattibile con qualche accorgimento.

Se non hai ancora *Docker* e *Docker Compose*, puoi seguire la [guida ufficiale per installarli](https://docs.docker.com/engine/install/ubuntu/) (presumendo tu stia usando una distribuzione basata su Debian, come Raspberry Pi OS).

```bash
# crea una cartella e muoviti all'interno
mkdir ./immich-app
cd ./immich-app
# scarica docker-compose.yml e .env
wget -O docker-compose.yml https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml
wget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env
# personalizza il file .env inserendo la cartella del raidbox
nano .env
```

#### 2.2. Run immich

```bash
# runna il docker
docker compose up -d
```

Prosegui dalla *gui web*: [http://\<IP\>:2283](https://www.google.com/search?q=http://IP:2283).

> ##### ATTENZIONE:
>
> Io ho avuto dei problemi con immich per colpa delle caratteristiche del mio raspberry (come anticipato, ha poca *RAM*). Per risolvere, **ho cancellato dal *docker-compose* le righe inerenti al *container* `immich_machine_learning`** (che richiede molte risorse) e **ho creato un [file di *swap*](https://wiki.archlinux.org/title/Swap_\(Italiano\))** per dare un po' di "memoria virtuale" in pi√π al sistema, alleggerendo leggermente la *RAM* fisica.

#### 2.3. SetUp external VPN

Per rendere il mio *cloud* raggiungibile anche fuori casa ho scelto [Tailscale](https://tailscale.com) per creare una [**VPN**](https://it.wikipedia.org/wiki/Virtual_Private_Network) (*Virtual Private Network*), servizio che consiglio per velocit√† e intuitivit√†.

### 3\. Backup 3-2-1

Il metodo di **backup 3-2-1** √® una strategia semplice e molto efficace per proteggere i dati.

Ecco cosa significa:

3 copie dei dati in totale:
  - 1 copia principale (quella che usi ogni giorno) + 2 copie di backup.

  - 2 tipi di supporti diversi.

  - 1 copia off-site (fuori sede).

> üëâ In breve: 3 copie, 2 supporti diversi, 1 in un altro posto.
√à la regola base per avere backup davvero **sicuri**.

#### 3.1. Due copie fisiche 

Il mio raidbox implementa vari metodi di [**RAID**](https://www.prepressure.com/library/technology/raid) (*Redundant Array of Independent Disks*) a livello hardware (se preferite un'implementazione software per una maggiore fluibilit√† ecco la guida di [HTML.it](https://www.html.it/pag/425575/creazione-e-gestione-di-un-sistema-raid/)). 
Io ho scelto il metodo **RAID 1** (*mirroring*), che crea una copia identica su entrambi i dischi.

#### 3.2. Hard disk montato sul router

Dopo aver collegato via usb il mio hard disk (**NTFS**) al mio router ho fatto l'accesso al mio gateway web (per me *http://192.168.1.1*) sono andato sulla sezione storage e ho visto il *PATH*.

Successivamente mi √® bastato montare l'hard disk sul raspberry con cifs.
```bash
sudo mount -t cifs //192.168.1.1/NomeShare /mnt/router_hdd -o username=admin,vers=3.0
```

#### 3.3. Terza copia locale con rsync

**rsync** √® un comando Linux usato per sincronizzare file e directory tra due posizioni, in modo efficiente: copia solo le differenze tra i file invece di riscriverli completamente.

```bash
# installa rsync
sudo apt install rsync -y
crontab -e 
# scrivi questa regola (ogni giorno alle 10 carica le foto, ripristina i permessi per evitare conflitti) 
0 10 * * * echo "Backup eseguito il $(date)" >> /home/chris/backup_log.txt && rsync -av --progress --no-perms --no-owner --no-group --exclude='lost+found' /mnt/raidbox/ /mnt/router_hdd/ >> /home/chris/backup_log.txt 2>&1 && echo "-------------------------" >> /home/chris/backup_log.txt
```

### 4\. Visualizzazione a schermo

Questo √® stato il punto in cui ho perso pi√π tempo.

L'obiettivo era creare un'interfaccia *touchscreen* semplice, reattiva e personalizzata per il mio *NAS*. Invece di usare un *framework* grafico pesante (come *Kivy* o un'interfaccia *web*), che avrebbe consumato troppe risorse sul Raspberry Pi 3b, ho deciso di "scendere" a un livello pi√π basso.

La soluzione √® stata scrivere degli *script* in Python che **disegnano direttamente sulla memoria video** dello schermo. Questo componente hardware si chiama [***framebuffer***](https://it.wikipedia.org/wiki/Framebuffer) (sul mio sistema, si trova in `/dev/fb1`).

L'architettura √® divisa in quattro file principali, ognuno con un compito preciso.

#### 4.1. `manager.py`: Il "Direttore d'Orchestra"

Questo √® il cervello dell'intera interfaccia. √à lo *script* principale che viene lanciato all'avvio e rimane sempre in esecuzione.

  * **Cosa fa:** Il suo unico compito √® **ascoltare il touchscreen**. Utilizza una libreria chiamata `evdev` per leggere gli input grezzi dal dispositivo (`/dev/input/event0`).
  * **Come funziona:** Ha una logica molto semplice (una "macchina a stati") per capire *dove* ho toccato lo schermo. Ad esempio, se tocco la met√† sinistra, sa che voglio l'app "YouTube". Se tocco la destra, voglio le "Impostazioni".
  * **La parte cruciale:** Quando decido di "aprire" un'app (ad esempio `yt.py`), il *manager* prima **termina forzatamente qualsiasi altra app** che era in esecuzione in quel momento (usando `os.killpg`) e *solo dopo* avvia il nuovo *script* (usando `subprocess.Popen`). Questo assicura che solo un programma alla volta stia cercando di disegnare sullo schermo, evitando conflitti.

In pratica, √® il "menu principale" che smista il lavoro e si assicura che tutti gli altri "programmi" si diano il cambio correttamente.

[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/screen/manager.py)

#### 4.2. `rpi.py`: La Dashboard di Monitoraggio

##### HOME
![Home](/images/1.png)

##### MEMORIA
![Memoria](/images/2.png)

##### SERVIZI
![Servizi](/images/3.png)

##### LOGS
![Logs](/images/4.png)

##### LOGS>SQUID
![Logs, squid](/images/5.png)

##### LOGS>NGINX
![Logs, nginx](/images/6.png)

##### LOGS>IMMICH DOCKER
![Logs, immich](/images/8.png)

##### PRESTAZIONI
![Prestazioni](/images/7.png)

Questo *script* √® l'applicazione pi√π complessa: √® la schermata di "Impostazioni" e monitoraggio.

  * **Cosa fa:** Disegna un'interfaccia utente (*UI*) completa con pulsanti, grafici e testo per mostrare lo stato del *NAS*.
  * **Come funziona:** A differenza degli altri *script*, questo non usa *tool* esterni per disegnare. Utilizza la fantastica libreria [**Pillow (PIL)**](https://pillow.readthedocs.io/en/stable/), che √® come un "Photoshop per codice".
    1.  Crea un'immagine vuota in memoria grande quanto lo schermo (480x320 *pixel*).
    2.  Usa le funzioni di Pillow per disegnare su questa immagine: rettangoli arrotondati per i pulsanti, testo per le etichette, barre di progresso colorate, ecc.
    3.  Per ottenere i dati, usa la libreria [**`psutil`**](https://www.google.com/search?q=%5Bhttps://psutil.readthedocs.io/en/latest/%5D\(https://psutil.readthedocs.io/en/latest/\)) (per sapere l'uso di CPU, *RAM* e *swap*) e lancia comandi `subprocess` (come `docker logs` o `journalctl`) per recuperare i *log* di sistema.
    4.  Una volta che l'immagine √® "pronta" e piena di informazioni, la converte nel formato grezzo dello schermo (`rgb565`) e la "spara" direttamente sul *framebuffer* (`/dev/fb1`), facendola apparire istantaneamente.
  * **Navigazione:** Ha anche un suo *listener* *touch* interno per permettermi di navigare tra le sotto-pagine (es. dalla *dashboard* principale alla pagina dei *log* di Nginx).

[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/screen/rpi.py)

#### 4.3. `immich.py`: Lo Slideshow di Foto

![Immich](/images/immich.png)

Questo √® uno *script* molto pi√π semplice, pensato per fare una cosa sola: mostrare le foto di famiglia.

  * **Cosa fa:** Avvia uno *slideshow* a schermo intero delle foto presenti nelle cartelle del mio *NAS* (quelle gestite da Immich).
  * **Come funziona:**
    1.  Scansiona le cartelle specificate per trovare tutti i file immagine.
    2.  Usa `itertools.cycle` per creare un *loop* infinito, cos√¨ quando finisce le foto ricomincia dalla prima.
    3.  **Non disegna nulla\!** Invece, usa un piccolo e velocissimo *tool* di Linux chiamato [***fbi***](https://manpages.debian.org/unstable/fbi/fbi.1.en.html) (*framebuffer image viewer*).
    4.  Lancia `fbi` tramite `subprocess` dicendogli: "mostra questa immagine sul *framebuffer* `/dev/fb1`".
    5.  Dopo averla lanciata, lo *script* va semplicemente in pausa (`time.sleep`) per 120 secondi.
    6.  Uso Pillow solo per una piccola utility: **ruotare le foto** di 180¬∞ prima di darle a `fbi`, per adattarle all'orientamento fisico del mio schermo.

√à un metodo "sporco" ma incredibilmente leggero in termini di risorse.

[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/screen/manager.py)

#### 4.4. `yt.py`: Il "Player" YouTube

Ho sempre avuto una passione per i video musicali - li trovo incredibilmente artistici, un perfetto connubio tra musica e visual art che riesce a trasmettere emozioni in modo unico. Per questo motivo questo script √® stato il pi√π divertente e complesso da realizzare. L'obiettivo era riprodurre video di YouTube direttamente sullo schermo.

  * **Cosa fa:** Effettua lo *streaming* di un video da YouTube e lo riproduce a schermo intero.
  * **Come funziona:** Non √® un *player* video scritto in Python (sarebbe troppo lento). √à un "ponte" che collega due potentissimi *tool* a riga di comando:
    1.  [**`yt-dlp`**](https://www.google.com/search?q=%5Bhttps://github.com/yt-dlp/yt-dlp%5D\(https://github.com/yt-dlp/yt-dlp\)): Per prima cosa, lo *script* esegue `yt-dlp` per ottenere l'URL diretto del *file* video (*stream*) da un normale link di YouTube.
    2.  [**FFmpeg**](https://ffmpeg.org/): Questo √® il "coltellino svizzero" per audio e video. Lo *script* avvia FFmpeg e gli d√† un comando molto specifico:
          * Prendi in *input* l'URL dello *stream* ottenuto da `yt-dlp`.
          * Ridimensiona il video (`scale`) a 480x320 *pixel*.
          * Ruotalo (`transpose`) per adattarlo allo schermo.
          * Convertilo in tempo reale nel formato grezzo `rgb565`.
          * Infine, **non salvarlo su file**, ma "sparalo" sul suo *output* standard (*stdout*).
    3.  **Il *Pipe***: Lo *script* Python cattura questo *output* da FFmpeg. Legge i dati fotogramma per fotogramma (`raw_frame = ffmpeg_proc.stdout.read(...)`).
    4.  **Scrittura su Framebuffer**: Appena riceve un fotogramma grezzo da FFmpeg, lo *script* lo scrive immediatamente sul *framebuffer* (`os.write(fb, raw_frame)`).

Ripetendo questa operazione migliaia di volte al secondo (leggere da FFmpeg -\> scrivere sul *framebuffer*), si ottiene un video fluido, usando pochissima *RAM* e delegando tutto il lavoro pesante di decodifica a FFmpeg.

[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/screen/yt.py)

**Perch√® ho ruotato tutto?**

*Avevo il caricatore sotto e non potevo appoggiarlo sul raidbox fr fr.*

---

> üí≠ Se hai idee o suggerimenti per migliorare il progetto, scrivimi pure su discord: *m9b3\_0b20ck*.

<style>
  .star-alert {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(5px);
    z-index: 10000;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: fadeIn 0.5s ease-out;
    transition: all 0.3s ease;
  }
  
  .star-alert.hidden {
    animation: fadeOut 0.3s ease-in forwards;
  }
  
  .star-alert-content {
    background: linear-gradient(135deg, #64ffda, #4cd3a7);
    color: #252a34;
    padding: 2rem 2.5rem;
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(100, 255, 218, 0.4);
    max-width: 400px;
    width: 90%;
    text-align: center;
    position: relative;
    transform: scale(0.8);
    animation: popIn 0.5s ease-out 0.2s forwards;
  }
  
  .star-icon {
    font-size: 3em;
    display: block;
    margin-bottom: 1rem;
    animation: sparkle 2s infinite;
  }
  
  .star-text {
    font-weight: 600;
    font-size: 1.1em;
    margin-bottom: 1.5rem;
    line-height: 1.4;
  }
  
  .star-button {
    background: #252a34;
    color: #64ffda;
    padding: 12px 24px;
    border-radius: 12px;
    text-decoration: none;
    font-weight: bold;
    font-size: 1em;
    transition: all 0.3s ease;
    border: 3px solid transparent;
    display: inline-block;
    margin-bottom: 1rem;
  }
  
  .star-button:hover {
    background: #1a1e25;
    border-color: #252a34;
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(37, 42, 52, 0.4);
  }
  
  .close-button {
    position: absolute;
    top: 15px;
    right: 20px;
    background: rgba(37, 42, 52, 0.1);
    border: none;
    font-size: 1.8em;
    cursor: pointer;
    color: #252a34;
    opacity: 0.7;
    transition: all 0.3s ease;
    padding: 5px;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .close-button:hover {
    opacity: 1;
    background: rgba(37, 42, 52, 0.2);
    transform: rotate(90deg);
  }
  
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  
  @keyframes fadeOut {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }
  
  @keyframes popIn {
    from {
      transform: scale(0.8);
      opacity: 0;
    }
    to {
      transform: scale(1);
      opacity: 1;
    }
  }
  
  @keyframes sparkle {
    0%, 100% {
      transform: scale(1) rotate(0deg);
    }
    25% {
      transform: scale(1.1) rotate(-5deg);
    }
    50% {
      transform: scale(1.2) rotate(0deg);
    }
    75% {
      transform: scale(1.1) rotate(5deg);
    }
  }
  
  /* Mobile responsive */
  @media (max-width: 768px) {
    .star-alert-content {
      padding: 1.5rem 2rem;
      margin: 1rem;
    }
    
    .star-icon {
      font-size: 2.5em;
    }
    
    .star-text {
      font-size: 1em;
    }
    
    .star-button {
      padding: 10px 20px;
      font-size: 0.9em;
    }
  }
</style>

<script>
(function() {
  const STORAGE_KEY = 'star-alert-dismissed';
  const SHOW_DELAY = 5000; // 5 seconds after page load
  
  function showStarAlert() {
    // Check if user has already dismissed the alert
    // if (localStorage.getItem(STORAGE_KEY) === 'true') {
    //   return;
    // }
    
    const alert = document.getElementById('star-alert');
    const closeButton = document.getElementById('close-star-alert');
    
    if (!alert || !closeButton) return;
    
    // Show alert after delay
    setTimeout(() => {
      alert.style.display = 'block';
    }, SHOW_DELAY);
    
    // Handle close button
    closeButton.addEventListener('click', function() {
      alert.classList.add('hidden');
      localStorage.setItem(STORAGE_KEY, 'true');
      
      setTimeout(() => {
        alert.style.display = 'none';
      }, 300);
    });
    
    // Auto-hide after 10 seconds if not interacted with
    setTimeout(() => {
      if (alert.style.display !== 'none' && !alert.classList.contains('hidden')) {
        alert.classList.add('hidden');
        setTimeout(() => {
          alert.style.display = 'none';
        }, 300);
      }
    }, 15000);
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', showStarAlert);
  } else {
    showStarAlert();
  }
})();
</script>