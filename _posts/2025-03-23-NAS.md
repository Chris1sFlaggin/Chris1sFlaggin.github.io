---
layout: single
title: "My personal NAS!"
date: 2025-10-19
categories: Projects
---

> ##### Disclaimer:
> Questa guida √® a scopo puramente educativo.

---

# Il progetto

> video generato con VEO3
<video width="100%" controls>
  <source src="/images/nas.mp4" type="video/mp4">
  Il tuo browser non supporta il tag video.
</video>

## L‚Äôintuizione

L‚Äôaltro giorno ero in universit√†. Tra una lezione in cui la concentrazione era ormai un miraggio e un‚Äôaltra che sembrava non finire mai, mi √® venuta un‚Äôidea:
**‚ÄúPerch√© non ho una [NAS](https://it.wikipedia.org/wiki/Network_Attached_Storage) in casa?\!‚Äù**.

Cos√¨, mentre cercavo di sembrare ancora minimamente attento, ho iniziato a pensare a cosa potrei farci. La prima idea √® stata un [***proxy cache***](https://www.google.com/search?q=https://it.wikipedia.org/wiki/Proxy%23Caching_proxy_server) ‚Äî ottimo progetto, e sicuramente lo realizzer√≤ in futuro ‚Äî ma non era quello che cercavo in quel momento.

Volevo qualcosa di **pratico ed esteticamente bello da tenere in camera**, qualcosa che potesse servire **anche ai miei genitori**, non solo a me e alle mie sperimentazioni tecniche.

-----

## L‚Äôidea

Dopo qualche minuto di *brainstorming*, ho buttato gi√π due direzioni principali:

  * ‚òÅÔ∏è **Un *cloud* personale** con [Immich](https://immich.app)
    Perfetto per gestire foto e video di famiglia, accessibile da qualsiasi dispositivo e con il controllo totale dei dati.
    Niente pi√π dipendenza da Google Photos o iCloud ‚Äî tutto in casa, tutto sotto il mio *NAS*.

  * üîÅ **Un [*reverse proxy*](https://it.wikipedia.org/wiki/Reverse_proxy)** per accedere a contenuti limitati sulle ***smart TV***. (_Vi lascio immaginare quali_).

-----

## Componenti

>(clicca sull'immagine per ottenere link)

### Raspberry Pi 3b

[![Raspberry Pi 3b](https://m.media-amazon.com/images/I/91zSu44+34L.jpg)](https://www.amazon.it/Raspberry-PI-Model-Scheda-madre/dp/B01CD5VC92)

### Custodia

[![3.5" Screen Case](https://m.media-amazon.com/images/I/61VWMWUQ-pL._AC_UF1000,1000_QL80_.jpg)](https://www.amazon.it/-/en/Raspberry-Supports-Raspbian-RetroPie-Multi-System/dp/B07NTH1JWH)

### Raidbox

[![Raidbox](https://m.media-amazon.com/images/I/61jotZv7FIL._AC_SL1500_.jpg)](https://www.amazon.it/-/en/RAID-CENMATE-Bay-Supports-Capacity/dp/B0DCZB849Y)

-----

## SetUp

### 1\. SetUp reverse proxy

Prima di iniziare, chiariamo cosa stiamo facendo. Per creare il nostro *reverse proxy*, installeremo due componenti software fondamentali: **Squid** e **Nginx**. In questa configurazione:

  * [**Nginx**](https://it.wikipedia.org/wiki/Nginx) (pronunciato *engine-x*) √® un *web server* ad alte prestazioni che useremo come [*reverse proxy*](https://www.cloudflare.com/it-it/learning/cdn/glossary/reverse-proxy/). Sar√† lui a ricevere le richieste dalla *smart TV* e a inoltrarle ai servizi di destinazione corretti.
  * [**Squid**](https://it.wikipedia.org/wiki/Squid) √® un [*proxy server*](https://www.fortinet.com/it/resources/cyberglossary/proxy-server) molto potente e versatile. In questo progetto lo useremo per la sua capacit√† di intercettare e modificare al volo le richieste e le risposte, ad esempio cambiando gli [*header HTTP*](https://www.google.com/search?q=https://developer.mozilla.org/it/docs/Web/HTTP/Headers). Questo √® il "trucco" che ci permetter√† di accedere ai contenuti desiderati.

#### 1.1. Squid

SSH sul raspberry e digita i seguenti comandi per installare *Squid*.

```bash
# installa squid
sudo apt install squid -y
# backup file conf
sudo mv /etc/squid/squid.conf /etc/squid/squid.conf.bak
# modifica file conf
sudo nano /etc/squid/squid.conf
```

Vi lascio il link al mio file funzionante:
[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/proxyConf/squid.conf)

```bash
# applica le modifiche e controlla lo stato
sudo systemctl restart squid
sudo systemctl enable squid
sudo systemctl status squid
```

> Verifica che lo stato sia Active: active (running).

#### 1.2. Nginx

```bash
# installa nginx
sudo apt install nginx -y
# rimuovi file conf default
sudo rm -f /etc/nginx/sites-enabled/default
# crea nuovo file conf
sudo nano /etc/nginx/sites-available/tv-proxy
```

Anche qui lascio il link al mio file funzionante:
[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/proxyConf/tv-proxy)

```bash
# crea un symlink dal tuo file di configurazione al directory sites-enabled.
sudo ln -s /etc/nginx/sites-available/tv-proxy /etc/nginx/sites-enabled/
# verifica la sintassi del tuo file conf
sudo nginx -t
```

```bash
# applica le modifiche
sudo systemctl restart nginx
sudo systemctl enable nginx
sudo systemctl status nginx
```

> Verifica che lo stato sia Active: active (running).

### 2\. SetUp immich

#### 2.1. Download immich

Per la memoria io ho montato un *raidbox*. Torneremo pi√π tardi sul perch√®.
Dopo averlo montato passiamo al prossimo passaggio.

##### Una nota su Docker

A differenza di Squid e Nginx, Immich non si installa "direttamente" sul sistema operativo. Invece, utilizza [**Docker**](https://www.google.com/search?q=https://it.wikipedia.org/wiki/Docker_\(informatica\)).

Pensa a *Docker* come a un sistema per impacchettare un'applicazione (come Immich) e tutte le sue dipendenze (database, librerie, ecc.) in una "scatola" autonoma e isolata, chiamata ***container***. Questo rende l'installazione e la gestione molto pi√π semplici, perch√© l'applicazione vive in un ambiente controllato senza "sporcare" il sistema principale (salvo malfunzionamenti vari dati da troppi container attivi, ma non fa il nostro caso).

Per gestire i vari servizi che compongono Immich, useremo [**Docker Compose**](https://docs.docker.com/compose/), uno strumento che legge un singolo file di configurazione per avviare e collegare tra loro pi√π *container* contemporaneamente.

**Importante:** Far girare *Docker* (e in particolare un'applicazione complessa come Immich) su un **Raspberry Pi 3b**, che ha risorse limitate (specialmente *RAM*), √® **prestazionalmente costoso**. L'avvio dei *container* potrebbe essere lento e le prestazioni generali del *NAS* potrebbero risentirne. √à una sfida, ma come vedremo, √® fattibile con qualche accorgimento.

Se non hai ancora *Docker* e *Docker Compose*, puoi seguire la [guida ufficiale per installarli](https://docs.docker.com/engine/install/ubuntu/) (presumendo tu stia usando una distribuzione basata su Debian, come Raspberry Pi OS).

```bash
# crea una cartella e muoviti all'interno
mkdir ./immich-app
cd ./immich-app
# scarica docker-compose.yml e .env
wget -O docker-compose.yml https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml
wget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env
# personalizza il file .env inserendo la cartella del raidbox
nano .env
```

#### 2.2. Run immich

```bash
# runna il docker
docker compose up -d
```

Prosegui dalla *gui web*: [http://\<IP\>:2283](https://www.google.com/search?q=http://IP:2283).

> ##### ATTENZIONE:
>
> Io ho avuto dei problemi con immich per colpa delle caratteristiche del mio raspberry (come anticipato, ha poca *RAM*). Per risolvere, **ho cancellato dal *docker-compose* le righe inerenti al *container* `immich_machine_learning`** (che richiede molte risorse) e **ho creato un [file di *swap*](https://wiki.archlinux.org/title/Swap_\(Italiano\))** per dare un po' di "memoria virtuale" in pi√π al sistema, alleggerendo leggermente la *RAM* fisica.

#### 2.3. SetUp external VPN

Per rendere il mio *cloud* raggiungibile anche fuori casa ho scelto [Tailscale](https://tailscale.com) per creare una [**VPN**](https://it.wikipedia.org/wiki/Virtual_Private_Network) (*Virtual Private Network*), servizio che consiglio per velocit√† e intuitivit√†.

### 3\. Backup 3-2-1

Il metodo di **backup 3-2-1** √® una strategia semplice e molto efficace per proteggere i dati.

Ecco cosa significa:

3 copie dei dati in totale:
  - 1 copia principale (quella che usi ogni giorno) + 2 copie di backup.

  - 2 tipi di supporti diversi.

  - 1 copia off-site (fuori sede).

> üëâ In breve: 3 copie, 2 supporti diversi, 1 in un altro posto.
√à la regola base per avere backup davvero **sicuri**.

#### 3.1. Due copie fisiche 

Il mio raidbox implementa vari metodi di [**RAID**](https://www.prepressure.com/library/technology/raid) (*Redundant Array of Independent Disks*) a livello hardware (se preferite un'implementazione software per una maggiore fluibilit√† ecco la guida di [HTML.it](https://www.html.it/pag/425575/creazione-e-gestione-di-un-sistema-raid/)). 
Io ho scelto il metodo **RAID 1** (*mirroring*), che crea una copia identica su entrambi i dischi.

#### 3.2. Hard disk montato sul router

Dopo aver collegato via usb il mio hard disk (**NTFS**) al mio router ho fatto l'accesso al mio gateway web (per me *http://192.168.1.1*) sono andato sulla sezione storage e ho visto il *PATH*.

Successivamente mi √® bastato montare l'hard disk sul raspberry con cifs.
```bash
sudo mount -t cifs //192.168.1.1/NomeShare /mnt/router_hdd -o username=admin,vers=3.0
```

#### 3.3. Terza copia locale con rsync

**rsync** √® un comando Linux usato per sincronizzare file e directory tra due posizioni, in modo efficiente: copia solo le differenze tra i file invece di riscriverli completamente.

```bash
# installa rsync
sudo apt install rsync -y
crontab -e 
# scrivi questa regola (ogni giorno alle 10 carica le foto, ripristina i permessi per evitare conflitti) 
0 10 * * * echo "Backup eseguito il $(date)" >> /home/chris/backup_log.txt && rsync -av --progress --no-perms --no-owner --no-group --exclude='lost+found' /mnt/raidbox/ /mnt/router_hdd/ >> /home/chris/backup_log.txt 2>&1 && echo "-------------------------" >> /home/chris/backup_log.txt
```

### 4\. Visualizzazione a schermo

Questo √® stato il punto in cui ho perso pi√π tempo.

L'obiettivo era creare un'interfaccia *touchscreen* semplice, reattiva e personalizzata per il mio *NAS*. Invece di usare un *framework* grafico pesante (come *Kivy* o un'interfaccia *web*), che avrebbe consumato troppe risorse sul Raspberry Pi 3b, ho deciso di "scendere" a un livello pi√π basso.

La soluzione √® stata scrivere degli *script* in Python che **disegnano direttamente sulla memoria video** dello schermo. Questo componente hardware si chiama [***framebuffer***](https://it.wikipedia.org/wiki/Framebuffer) (sul mio sistema, si trova in `/dev/fb1`).

L'architettura √® divisa in quattro file principali, ognuno con un compito preciso.

#### 4.1. `manager.py`: Il "Direttore d'Orchestra"

Questo √® il cervello dell'intera interfaccia. √à lo *script* principale che viene lanciato all'avvio e rimane sempre in esecuzione.

  * **Cosa fa:** Il suo unico compito √® **ascoltare il touchscreen**. Utilizza una libreria chiamata `evdev` per leggere gli input grezzi dal dispositivo (`/dev/input/event0`).
  * **Come funziona:** Ha una logica molto semplice (una "macchina a stati") per capire *dove* ho toccato lo schermo. Ad esempio, se tocco la met√† sinistra, sa che voglio l'app "YouTube". Se tocco la destra, voglio le "Impostazioni".
  * **La parte cruciale:** Quando decido di "aprire" un'app (ad esempio `yt.py`), il *manager* prima **termina forzatamente qualsiasi altra app** che era in esecuzione in quel momento (usando `os.killpg`) e *solo dopo* avvia il nuovo *script* (usando `subprocess.Popen`). Questo assicura che solo un programma alla volta stia cercando di disegnare sullo schermo, evitando conflitti.

In pratica, √® il "menu principale" che smista il lavoro e si assicura che tutti gli altri "programmi" si diano il cambio correttamente.

[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/screen/manager.py)

#### 4.2. `rpi.py`: La Dashboard di Monitoraggio

##### HOME
![Home](/images/1.png)

##### MEMORIA
![Memoria](/images/2.png)

##### SERVIZI
![Servizi](/images/3.png)

##### LOGS
![Logs](/images/4.png)

##### LOGS>SQUID
![Logs, squid](/images/5.png)

##### LOGS>NGINX
![Logs, nginx](/images/6.png)

##### LOGS>IMMICH DOCKER
![Logs, immich](/images/8.png)

##### PRESTAZIONI
![Prestazioni](/images/7.png)

Questo *script* √® l'applicazione pi√π complessa: √® la schermata di "Impostazioni" e monitoraggio.

  * **Cosa fa:** Disegna un'interfaccia utente (*UI*) completa con pulsanti, grafici e testo per mostrare lo stato del *NAS*.
  * **Come funziona:** A differenza degli altri *script*, questo non usa *tool* esterni per disegnare. Utilizza la fantastica libreria [**Pillow (PIL)**](https://pillow.readthedocs.io/en/stable/), che √® come un "Photoshop per codice".
    1.  Crea un'immagine vuota in memoria grande quanto lo schermo (480x320 *pixel*).
    2.  Usa le funzioni di Pillow per disegnare su questa immagine: rettangoli arrotondati per i pulsanti, testo per le etichette, barre di progresso colorate, ecc.
    3.  Per ottenere i dati, usa la libreria [**`psutil`**](https://www.google.com/search?q=%5Bhttps://psutil.readthedocs.io/en/latest/%5D\(https://psutil.readthedocs.io/en/latest/\)) (per sapere l'uso di CPU, *RAM* e *swap*) e lancia comandi `subprocess` (come `docker logs` o `journalctl`) per recuperare i *log* di sistema.
    4.  Una volta che l'immagine √® "pronta" e piena di informazioni, la converte nel formato grezzo dello schermo (`rgb565`) e la "spara" direttamente sul *framebuffer* (`/dev/fb1`), facendola apparire istantaneamente.
  * **Navigazione:** Ha anche un suo *listener* *touch* interno per permettermi di navigare tra le sotto-pagine (es. dalla *dashboard* principale alla pagina dei *log* di Nginx).

[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/screen/rpi.py)

#### 4.3. `immich.py`: Lo Slideshow di Foto

![Immich](/images/immich.png)

Questo √® uno *script* molto pi√π semplice, pensato per fare una cosa sola: mostrare le foto di famiglia.

  * **Cosa fa:** Avvia uno *slideshow* a schermo intero delle foto presenti nelle cartelle del mio *NAS* (quelle gestite da Immich).
  * **Come funziona:**
    1.  Scansiona le cartelle specificate per trovare tutti i file immagine.
    2.  Usa `itertools.cycle` per creare un *loop* infinito, cos√¨ quando finisce le foto ricomincia dalla prima.
    3.  **Non disegna nulla\!** Invece, usa un piccolo e velocissimo *tool* di Linux chiamato [***fbi***](https://manpages.debian.org/unstable/fbi/fbi.1.en.html) (*framebuffer image viewer*).
    4.  Lancia `fbi` tramite `subprocess` dicendogli: "mostra questa immagine sul *framebuffer* `/dev/fb1`".
    5.  Dopo averla lanciata, lo *script* va semplicemente in pausa (`time.sleep`) per 120 secondi.
    6.  Uso Pillow solo per una piccola utility: **ruotare le foto** di 180¬∞ prima di darle a `fbi`, per adattarle all'orientamento fisico del mio schermo.

√à un metodo "sporco" ma incredibilmente leggero in termini di risorse.

[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/screen/manager.py)

#### 4.4. `yt.py`: Il "Player" YouTube


Ho sempre avuto una passione per i video musicali - li trovo incredibilmente artistici, un perfetto connubio tra musica e visual art che riesce a trasmettere emozioni in modo unico. Per questo motivo questo script √® stato il pi√π divertente e complesso da realizzare. L'obiettivo era riprodurre video di YouTube (nello specifico, una *playlist* di video-camini) direttamente sullo schermo.

  * **Cosa fa:** Effettua lo *streaming* di un video da YouTube e lo riproduce a schermo intero.
  * **Come funziona:** Non √® un *player* video scritto in Python (sarebbe troppo lento). √à un "ponte" che collega due potentissimi *tool* a riga di comando:
    1.  [**`yt-dlp`**](https://www.google.com/search?q=%5Bhttps://github.com/yt-dlp/yt-dlp%5D\(https://github.com/yt-dlp/yt-dlp\)): Per prima cosa, lo *script* esegue `yt-dlp` per ottenere l'URL diretto del *file* video (*stream*) da un normale link di YouTube.
    2.  [**FFmpeg**](https://ffmpeg.org/): Questo √® il "coltellino svizzero" per audio e video. Lo *script* avvia FFmpeg e gli d√† un comando molto specifico:
          * Prendi in *input* l'URL dello *stream* ottenuto da `yt-dlp`.
          * Ridimensiona il video (`scale`) a 480x320 *pixel*.
          * Ruotalo (`transpose`) per adattarlo allo schermo.
          * Convertilo in tempo reale nel formato grezzo `rgb565`.
          * Infine, **non salvarlo su file**, ma "sparalo" sul suo *output* standard (*stdout*).
    3.  **Il *Pipe***: Lo *script* Python cattura questo *output* da FFmpeg. Legge i dati fotogramma per fotogramma (`raw_frame = ffmpeg_proc.stdout.read(...)`).
    4.  **Scrittura su Framebuffer**: Appena riceve un fotogramma grezzo da FFmpeg, lo *script* lo scrive immediatamente sul *framebuffer* (`os.write(fb, raw_frame)`).

Ripetendo questa operazione migliaia di volte al secondo (leggere da FFmpeg -\> scrivere sul *framebuffer*), si ottiene un video fluido, usando pochissima *RAM* e delegando tutto il lavoro pesante di decodifica a FFmpeg.

[Link al mio file](https://github.com/Chris1sFlaggin/NAS/blob/main/screen/yt.py)

**Perch√® ho ruotato tutto?**

*Avevo il caricatore sotto e non potevo appoggiarlo sul raidbox fr fr.*

---

> üí≠ Se hai idee o suggerimenti per migliorare il progetto, scrivimi pure su discord: *m9b3\_0b20ck*.