<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Algoritmi e Strutture Dati</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        canvas {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: pointer;
        }
        .footer {
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }
    </style>
</head>
<body>

    <h1>Verifica: Algoritmi e Strutture Dati</h1>
    <canvas id="quizCanvas" width="800" height="600"></canvas>
    <div class="footer">Clicca sulle opzioni per rispondere</div>

<script>
// --- DATA: DOMANDE E RISPOSTE ---
const questions = [
    {
        category: "Calcolo Costo T(n)",
        question: "Esercizio 1: Qual è il costo T(n) esatto di questo ciclo While?",
        code: [
            "x <- 0",
            "i <- 1",
            "WHILE (i <= n) DO",
            "    x <- x + 2",
            "    i <- i + 1",
            "END WHILE",
            "WRITE(x)"
        ],
        options: ["3n + 4", "3n + 5", "4n + 1", "3n + 1"],
        correct: 1, // Indice della risposta corretta (0-based)
        explanation: "Corretto: 3n + 5. (1+1+1 iniziali + 2n corpo + n+1 test + 1 write)."
    },
    {
        category: "Cicli Annidati",
        question: "Esercizio 2: Qual è l'ordine di grandezza (Big O) dell'istruzione WRITE(k)?",
        code: [
            "k <- 0",
            "FOR (i <- 0; i < n; i++)",
            "    FOR (j <- 0; j < n; j++)",
            "        k <- k + 1",
            "        WRITE(k)",
            "    END FOR",
            "END FOR"
        ],
        options: ["O(n)", "O(n^2)", "O(2n)", "O(1)"],
        correct: 1,
        explanation: "Esatto! Due cicli annidati da 0 a n generano n * n = n^2 iterazioni."
    },
    {
        category: "Riconoscimento Algoritmi",
        question: "Esercizio 3: Di quale algoritmo di ordinamento si tratta?",
        code: [
            "FOR (i <- 1; i < n-1; i++)",
            "   min <- i",
            "   FOR (j <- i+1; j < n; j++)",
            "       IF (A[j] < A[min]) min <- j",
            "   IF (min != i) swap A[i], A[min]"
        ],
        options: ["Bubble Sort", "Insertion Sort", "Selection Sort", "Merge Sort"],
        correct: 2,
        explanation: "Giusto. Cerca il minimo e lo scambia: è il Selection Sort."
    },
    {
        category: "Logica Algoritmi",
        question: "Esercizio 4: Cosa succede al Selection Sort se l'array è già ordinato?",
        code: [],
        options: ["Termina subito in O(1)", "Esegue comunque O(n^2)", "Diventa O(n)", "L'algoritmo fallisce"],
        correct: 1,
        explanation: "Corretto. Il Selection Sort non ha flag di controllo, esegue sempre tutti i confronti."
    },
    {
        category: "Strutture Dati: Liste",
        question: "Esercizio 5: Qual è il costo Big O dell'inserimento in TESTA?",
        code: [],
        options: ["O(n)", "O(1)", "O(log n)", "O(n^2)"],
        correct: 1,
        explanation: "Esatto. Basta aggiornare i puntatori della testa, non serve scorrere la lista."
    },
    {
        category: "Strutture Dati: Code",
        question: "Esercizio 6: Queue: Enqueue(5), Enqueue(10), Dequeue(). Chi esce?",
        code: [],
        options: ["5", "10", "3", "Nessuno"],
        correct: 0,
        explanation: "Corretto. La Coda è FIFO (First In First Out). Il 5 è entrato per primo."
    },
    {
        category: "Binary Search",
        question: "Esercizio 7: Quale pre-condizione è necessaria per la Binary Search?",
        code: [],
        options: ["Numeri positivi", "Array Ordinato", "Nessun duplicato", "Dimensione potenza di 2"],
        correct: 1,
        explanation: "Giusto. Senza ordinamento non possiamo scartare metà array."
    },
    {
        category: "Ricorsione",
        question: "Esercizio 8: In Binary Search ricorsiva, se l > r cosa significa?",
        code: [],
        options: ["Trovato", "Non trovato (-1)", "Primo elemento", "Loop infinito"],
        correct: 1,
        explanation: "Esatto. Gli indici si sono incrociati senza trovare l'elemento."
    },
    {
        category: "Alberi",
        question: "Esercizio 9: Cosa sono le 'Foglie' in un albero?",
        code: [],
        options: ["Il nodo radice", "Nodi senza figli", "Nodi interni", "I rami"],
        correct: 1,
        explanation: "Corretto. Le foglie sono i nodi terminali che non hanno successori."
    },
    {
        category: "Complessità",
        question: "Esercizio 10: Qual è la complessità MIGLIORE (più veloce)?",
        code: [],
        options: ["O(n^2)", "O(n)", "O(1)", "O(log n)"],
        correct: 2,
        explanation: "Esatto. O(1) è tempo costante, il più veloce possibile."
    },
    {
        category: "Confronto Ordinamento",
        question: "Esercizio 11: Quale algoritmo è generalmente più efficiente su un array quasi ordinato?",
        code: [],
        options: ["Selection Sort", "Insertion Sort", "Bubble Sort (senza flag)", "Sono uguali"],
        correct: 1,
        explanation: "L'Insertion Sort è molto efficiente su array quasi ordinati (O(n)), mentre il Selection fa sempre O(n^2) controlli."
    },
    {
        category: "Calcolo Costo T(n)",
        question: "Esercizio 12: Calcola il costo dell'istruzione IF-ELSE nel caso peggiore.",
        code: [
            "IF (x > 0) THEN",
            "   a <- 1",
            "ELSE",
            "   a <- 2",
            "   b <- 3"
        ],
        options: ["Costo del THEN", "Costo dell'ELSE", "Costo del test + Costo ELSE (blocco più lungo)", "Costo test + Costo THEN"],
        correct: 2,
        explanation: "Come indicato a pag. 13[cite: 136], per il costo totale si considera il test più il caso peggiore (il ramo con più istruzioni)."
    },
    {
        category: "Strutture Dati: Liste",
        question: "Esercizio 13: In una Lista Concatenata (Linked List), quanto costa accedere all'elemento k-esimo?",
        code: [],
        options: ["O(1)", "O(n)", "O(log n)", "O(n^2)"],
        correct: 1,
        explanation: "O(n)[cite: 52]. A differenza degli array, bisogna scorrere i puntatori dal primo nodo fino al k-esimo."
    },
    {
        category: "Complessità Spaziale",
        question: "Esercizio 14: Qual è la complessità spaziale della dichiarazione 'int X[N]'?",
        code: [],
        options: ["O(1)", "O(n)", "O(n^2)", "O(log n)"],
        correct: 1,
        explanation: "O(n)[cite: 33]. Si allocano N celle di memoria."
    },
    {
        category: "Strutture Dati: Code",
        question: "Esercizio 15: Secondo il PDF, qual è il costo della 'RIMOZIONE IN CODA' in una Queue standard?",
        code: [],
        options: ["O(1)", "O(n)", "O(log n)", "O(n^2)"],
        correct: 1,
        explanation: "O(n)[cite: 69]. Rimuovere dal fondo richiede di scorrere tutto se non è doppiamente linkata o ottimizzata."
    },
    {
        category: "Alberi",
        question: "Esercizio 16: In un albero, come si chiama il nodo che non ha padri?",
        code: [],
        options: ["Foglia", "Radice", "Nodo Interno", "Ramo"],
        correct: 1,
        explanation: "Radice[cite: 91]. È il nodo in cima alla gerarchia."
    },
    {
        category: "Confronto Ricerca",
        question: "Esercizio 17: Linear Search vs Binary Search. Quando conviene usare la Linear Search?",
        code: [],
        options: ["Sempre", "Quando l'array è molto grande", "Quando l'array NON è ordinato", "Mai"],
        correct: 2,
        explanation: "La Binary Search richiede dati ordinati[cite: 237]. Se i dati sono disordinati, la Linear Search è l'unica opzione immediata."
    },
    {
        category: "Calcolo Costo T(n)",
        question: "Esercizio 18: Qual è il costo di questo assegnamento in un ciclo FOR?",
        code: [
            "FOR (i <- 0; i < n; i++)",
            "   x <- x + 1"
        ],
        options: ["n", "n + 1", "n * 1", "2n"],
        correct: 2,
        explanation: "L'istruzione interna viene eseguita n volte, e ha costo unitario 1. Totale corpo: n*1[cite: 164]."
    },
    {
        category: "Riconoscimento Algoritmi",
        question: "Esercizio 19: Identifica l'algoritmo dal codice.",
        code: [
            "FOR (i <- 0; i < n-1; i++)",
            "  FOR (j <- 0; j < n-j-1; j++)",
            "    IF (A[j] > A[j+1]) swap..."
        ],
        options: ["Insertion Sort", "Selection Sort", "Bubble Sort", "Merge Sort"],
        correct: 2,
        explanation: "Bubble Sort[cite: 227]. Si riconosce dai due cicli e dallo scambio tra adiacenti (j e j+1)."
    },
    {
        category: "Complessità",
        question: "Esercizio 20: Cosa indica la notazione O(n^2)?",
        code: [],
        options: ["Crescita Lineare", "Crescita Logaritmica", "Crescita Quadratica", "Crescita Esponenziale"],
        correct: 2,
        explanation: "Quadratica[cite: 34]. Tipica dei doppi cicli annidati."
    },
    {
        category: "Logica Algoritmi",
        question: "Esercizio 21: Cosa fa l'istruzione 'swap A[j] and A[j+1]'?",
        code: [],
        options: ["Elimina A[j]", "Copia A[j] in A[j+1]", "Scambia i valori delle due celle", "Sposta tutto l'array"],
        correct: 2,
        explanation: "Scambia i valori[cite: 15]. È l'operazione fondamentale degli ordinamenti."
    },
    {
        category: "Grafi",
        question: "Esercizio 22: Un grafo è composto da...?",
        code: [],
        options: ["Solo Nodi", "Nodi e Archi (relazioni)", "Solo Archi", "Alberi binari"],
        correct: 1,
        explanation: "Nodi e collegamenti (archi/relazioni), come mostrato nell'immagine del social network[cite: 96]."
    },
    {
        category: "Calcolo Costo T(n)",
        question: "Esercizio 23: Qual è il costo totale esatto di questo snippet?",
        code: [
            "READ(n)     // Costo 1",
            "i <- 1      // Costo 1",
            "WRITE(n)    // Costo 1"
        ],
        options: ["3", "n", "3n", "1"],
        correct: 0,
        explanation: "La somma delle istruzioni semplici è 1 + 1 + 1 = 3 [cite: 106-110]."
    },
    {
        category: "Strutture Dati",
        question: "Esercizio 24: Quale struttura segue il principio L.I.F.O. (Last In First Out)?",
        code: [],
        options: ["Coda (Queue)", "Lista (Stack behavior)", "Albero", "Grafo"],
        correct: 1,
        explanation: "Le Liste (usate come Stack) sono associate a LIFO nel documento[cite: 46]. Le Code sono FIFO."
    },
    {
        category: "Confronto Algoritmi",
        question: "Esercizio 25: Selection Sort vs Insertion Sort. Quale fa meno scambi (swaps) nel caso medio?",
        code: [],
        options: ["Selection Sort", "Insertion Sort", "Fanno gli stessi scambi", "Bubble Sort"],
        correct: 0,
        explanation: "Il Selection Sort fa al massimo N scambi (uno per iterazione esterna)[cite: 225], mentre l'Insertion fa molti spostamenti."
    },
    {
        category: "Binary Search",
        question: "Esercizio 26: Come si calcola l'indice medio 'm' nella ricerca binaria?",
        code: [],
        options: ["m <- l + r", "m <- (l + r) / 2", "m <- n / 2", "m <- l - r"],
        correct: 1,
        explanation: "La formula corretta è la media tra indice sinistro (l) e destro (r): m <- (l+r)/2[cite: 241]."
    },
    {
        category: "Complessità",
        question: "Esercizio 27: Qual è il T(n) semplificato di '3n + 6'?",
        code: [],
        options: ["O(1)", "O(n)", "O(n^2)", "O(log n)"],
        correct: 1,
        explanation: "Si eliminano costanti e termini inferiori. Rimane O(n)[cite: 195]."
    },
    {
        category: "Strutture Dati: Code",
        question: "Esercizio 28: Quale operazione ha costo O(1) in una Coda (implementazione PDF)?",
        code: [],
        options: ["Inserimento in Testa", "Rimozione in Coda", "Inserimento in Coda", "Accesso elemento"],
        correct: 2,
        explanation: "Inserimento in Coda è O(1)[cite: 67], mentre l'inserimento in testa è O(n) in questa specifica implementazione."
    },
    {
        category: "Ordinamento",
        question: "Esercizio 29: In quale caso il Bubble Sort è più lento (Worst Case)?",
        code: [],
        options: ["Array già ordinato", "Array ordinato al contrario", "Array con numeri uguali", "Array vuoto"],
        correct: 1,
        explanation: "Se l'array è inverso, deve fare il massimo numero di scambi possibile."
    },
    {
        category: "Ricorsione",
        question: "Esercizio 30: Cosa manca in questo codice ricorsivo per evitare il loop infinito?",
        code: [
            "Func(x)",
            "  RETURN Func(x+1)"
        ],
        options: ["Un ciclo While", "Il caso base (condizione di uscita)", "Una variabile globale", "Un print"],
        correct: 1,
        explanation: "Manca il caso base (es. IF l>r RETURN -1 nella Binary Search)[cite: 254]."
    },
    {
        category: "Confronto Strutture",
        question: "Esercizio 31: Lista vs Array. Quale permette il ridimensionamento dinamico più facile?",
        code: [],
        options: ["Array Statico", "Lista", "Matrice", "Record"],
        correct: 1,
        explanation: "Le liste sono strutture dinamiche[cite: 36], si allocano nodi al bisogno. Gli array hanno dimensione fissa (int X[N])."
    },
    {
        category: "Calcolo Costo",
        question: "Esercizio 32: Quanto costa il test 'i < n' in un ciclo FOR ripetuto n volte?",
        code: [],
        options: ["n", "n + 1", "1", "n^2"],
        correct: 1,
        explanation: "Il test viene eseguito n volte vere + 1 volta falsa (uscita). Totale n+1[cite: 164]."
    },
    {
        category: "Logica Algoritmi",
        question: "Esercizio 33: Nell'Insertion Sort, il ciclo WHILE serve a...?",
        code: [
            "WHILE (j >= 0 AND A[j] > t)",
            "   A[j+1] <- A[j]",
            "   j <- j - 1"
        ],
        options: ["Trovare il minimo", "Shiftare gli elementi maggiori a destra", "Scambiare elementi a caso", "Incrementare l'indice"],
        correct: 1,
        explanation: "Sposta (shifta) gli elementi più grandi per fare spazio all'elemento 't' da inserire [cite: 215-216]."
    },
    {
        category: "Alberi",
        question: "Esercizio 34: In un albero binario, ogni nodo quanti figli può avere al massimo?",
        code: [],
        options: ["Infiniti", "Esattamente 3", "Al massimo 2", "Almeno 1"],
        correct: 2,
        explanation: "Binario significa che ogni nodo ha al massimo 2 figli (sinistro e destro)[cite: 76]."
    },
    {
        category: "Complessità",
        question: "Esercizio 35: Qual è la complessità di due cicli FOR NON annidati (uno dopo l'altro)?",
        code: [
            "FOR (i...n) ...",
            "FOR (j...n) ..."
        ],
        options: ["O(n^2)", "O(n)", "O(1)", "O(log n)"],
        correct: 1,
        explanation: "Si sommano i costi: n + n = 2n. In Big O, le costanti si ignorano -> O(n)."
    },
    {
        category: "Ricerca",
        question: "Esercizio 36: Se Binary Search non trova l'elemento k, cosa restituisce?",
        code: [],
        options: ["0", "Il valore più vicino", "-1", "Errore"],
        correct: 2,
        explanation: "Restituisce -1 quando l > r[cite: 248]."
    },
    {
        category: "Liste",
        question: "Esercizio 37: Cosa contiene il campo 'next' di un nodo in una lista?",
        code: [],
        options: ["Il valore del dato", "L'indirizzo del nodo successivo", "NULL sempre", "L'indice dell'array"],
        correct: 1,
        explanation: "Contiene il puntatore/riferimento al prossimo nodo della catena[cite: 37]."
    },
    {
        category: "Confronto Algoritmi",
        question: "Esercizio 38: Qual è la complessità temporale PEGGIORE condivisa da Bubble, Selection e Insertion Sort?",
        code: [],
        options: ["O(n)", "O(n log n)", "O(n^2)", "O(1)"],
        correct: 2,
        explanation: "Tutti e tre sono algoritmi quadratici O(n^2) nel caso peggiore[cite: 202]."
    },
    {
        category: "Calcolo Costo",
        question: "Esercizio 39: Nel calcolo 4n^2 + 3, qual è il termine dominante?",
        code: [],
        options: ["3", "4", "n", "n^2"],
        correct: 3,
        explanation: "Per n che tende a infinito, n^2 cresce più velocemente di tutto il resto[cite: 204]."
    },
    {
        category: "Strutture Dati",
        question: "Esercizio 40: Qual è l'ultimo elemento di una Lista concatenata?",
        code: [],
        options: ["First", "Quello che punta a NULL", "Quello con indice 0", "La radice"],
        correct: 1,
        explanation: "L'ultimo nodo ha il campo next che punta a NULL[cite: 43]."
    },
    {
        category: "Pseudocodice",
        question: "Esercizio 41: Cosa significa la freccia sinistra (<-) nello pseudocodice?",
        code: ["x <- x + 1"],
        options: ["Confronto", "Assegnazione", "Minore di", "Puntatore"],
        correct: 1,
        explanation: "Indica l'assegnazione di un valore a una variabile[cite: 109]."
    },
    {
        category: "Alberi",
        question: "Esercizio 42: Cosa sono i nodi 'fratelli' (siblings)?",
        code: [],
        options: ["Nodi con lo stesso padre", "Nodi su livelli diversi", "Padre e figlio", "La radice e le foglie"],
        correct: 0,
        explanation: "Sono i figli dello stesso nodo padre[cite: 95]."
    },
    {
        category: "Algoritmi di Ricerca",
        question: "Esercizio 43: Quanti confronti fa la Binary Search su 8 elementi nel caso peggiore?",
        code: [],
        options: ["8", "3", "64", "1"],
        correct: 1,
        explanation: "Log2(8) = 3. Divide l'array a metà 3 volte (8 -> 4 -> 2 -> 1)."
    },
    {
        category: "Confronto Code e Liste",
        question: "Esercizio 44: 'Enqueue' sta alle Code come 'Push' sta a...?",
        code: [],
        options: ["Liste (Stack)", "Alberi", "Grafi", "Array"],
        correct: 0,
        explanation: "Push è il termine usato per l'inserimento negli Stack (implementati con Liste OOL)[cite: 24]."
    },
    {
        category: "Calcolo Costo",
        question: "Esercizio 45: Costo di inizializzazione 'int X[M][N]' (Matrice)?",
        code: [],
        options: ["O(n)", "O(n^2) / O(M*N)", "O(1)", "O(log n)"],
        correct: 1,
        explanation: "O(n^2) o meglio M*N, poiché bisogna allocare tutte le celle della matrice[cite: 35]."
    },
    {
        category: "Selection Sort",
        question: "Esercizio 46: Nel Selection Sort, a cosa serve la variabile 'min'?",
        code: [],
        options: ["Conta i cicli", "Memorizza l'indice dell'elemento più piccolo trovato", "Memorizza il valore massimo", "Scambia i valori"],
        correct: 1,
        explanation: "Tiene traccia della posizione del valore minimo nel sotto-array non ordinato[cite: 220]."
    },
    {
        category: "Logica",
        question: "Esercizio 47: Se dimezzo l'input (n/2) ad ogni passo, la complessità è...?",
        code: [],
        options: ["Lineare O(n)", "Quadratica O(n^2)", "Logaritmica O(log n)", "Costante O(1)"],
        correct: 2,
        explanation: "Tipico della Binary Search. Dividere ripetutamente porta a logaritmo in base 2."
    },
    {
        category: "Definizioni",
        question: "Esercizio 48: Cosa significa FIFO?",
        code: [],
        options: ["First In First Out", "First In Last Out", "Fast In Fast Out", "File Input File Output"],
        correct: 0,
        explanation: "Il primo ad entrare è il primo ad uscire. Tipico delle Code[cite: 64]."
    },
    {
        category: "Grafi",
        question: "Esercizio 49: Un social network (utenti e amicizie) è rappresentabile meglio con:",
        code: [],
        options: ["Una Coda", "Un Grafo", "Uno Stack", "Un Array ordinato"],
        correct: 1,
        explanation: "I grafi modellano bene le connessioni complesse tra entità, come in un social network[cite: 96]."
    },
    {
        category: "Analisi Finale",
        question: "Esercizio 50: Perché calcoliamo il 'limite per n che tende a infinito'?",
        code: [],
        options: ["Per trovare il valore esatto in secondi", "Per capire il comportamento asintotico su grandi dati", "Per risolvere equazioni", "Non serve a nulla"],
        correct: 1,
        explanation: "Serve a confrontare gli algoritmi indipendentemente dall'hardware, su input grandi[cite: 204]."
    }
];

// --- ENGINE DEL QUIZ ---
const canvas = document.getElementById('quizCanvas');
const ctx = canvas.getContext('2d');

// Stati del gioco
const STATE_START = 0;
const STATE_QUESTION = 1;
const STATE_FEEDBACK = 2;
const STATE_END = 3;

let currentState = STATE_START;
let currentQuestionIndex = 0;
let score = 0;
let feedbackMessage = "";
let isCorrect = false;

// Coordinate dei pulsanti (verranno calcolate dinamicamente)
let buttons = [];

// Funzioni di disegno
function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function drawButton(x, y, w, h, text, color, hover) {
    ctx.fillStyle = color;
    // Ombra
    ctx.shadowColor = "rgba(0,0,0,0.2)";
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    // Rettangolo stondato
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, 10);
    ctx.fill();
    
    // Reset ombra per il testo
    ctx.shadowColor = "transparent";
    
    ctx.fillStyle = "#fff";
    ctx.font = "bold 18px 'Segoe UI'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, x + w/2, y + h/2);
    
    return {x, y, w, h}; // Ritorna le coordinate per il click
}

function drawStartScreen() {
    clearCanvas();
    ctx.fillStyle = "#2c3e50";
    ctx.font = "bold 40px 'Segoe UI'";
    ctx.textAlign = "center";
    ctx.fillText("Quiz Algoritmi", canvas.width/2, 200);
    
    ctx.font = "20px 'Segoe UI'";
    ctx.fillStyle = "#7f8c8d";
    ctx.fillText("50 Domande - Clicca Inizia per partire", canvas.width/2, 250);
    
    buttons = [];
    let btn = drawButton(canvas.width/2 - 100, 350, 200, 60, "INIZIA", "#27ae60");
    buttons.push({area: btn, action: 'START'});
}

function drawEndScreen() {
    clearCanvas();
    ctx.fillStyle = "#2c3e50";
    ctx.font = "bold 40px 'Segoe UI'";
    ctx.textAlign = "center";
    ctx.fillText("Quiz Completato!", canvas.width/2, 150);
    
    ctx.font = "30px 'Segoe UI'";
    ctx.fillStyle = "#2980b9";
    ctx.fillText(`Punteggio: ${score} su ${questions.length}`, canvas.width/2, 220);
    
    let comment = "";
    if(score === 10) comment = "Eccellente! Sei pronto per l'esame.";
    else if(score >= 6) comment = "Buon lavoro! Ripassa gli errori.";
    else comment = "Serve più studio sulle slide.";
    
    ctx.font = "italic 20px 'Segoe UI'";
    ctx.fillStyle = "#7f8c8d";
    ctx.fillText(comment, canvas.width/2, 270);
    
    buttons = [];
    let btn = drawButton(canvas.width/2 - 120, 380, 240, 60, "Riprova", "#e67e22");
    buttons.push({area: btn, action: 'RESTART'});
}

function drawQuestionScreen() {
    clearCanvas();
    const q = questions[currentQuestionIndex];
    buttons = []; // Reset pulsanti

    // Intestazione
    ctx.fillStyle = "#34495e";
    ctx.fillRect(0, 0, canvas.width, 60);
    ctx.fillStyle = "#fff";
    ctx.font = "bold 20px 'Segoe UI'";
    ctx.textAlign = "left";
    ctx.fillText(`Domanda ${currentQuestionIndex + 1}/${questions.length}: ${q.category}`, 20, 35);
    
    ctx.textAlign = "right";
    ctx.fillText(`Punti: ${score}`, canvas.width - 20, 35);

    // Testo Domanda
    ctx.fillStyle = "#2c3e50";
    ctx.font = "22px 'Segoe UI'";
    ctx.textAlign = "center";
    // Semplice word wrap manuale se necessario, qui assumiamo testo su una riga per semplicità o usiamo max-width
    wrapText(ctx, q.question, canvas.width/2, 100, 700, 30);

    let currentY = 160;

    // Box Codice (se presente)
    if (q.code && q.code.length > 0) {
        ctx.fillStyle = "#ecf0f1";
        const boxHeight = q.code.length * 25 + 20;
        ctx.fillRect(150, currentY, 500, boxHeight);
        ctx.strokeStyle = "#bdc3c7";
        ctx.strokeRect(150, currentY, 500, boxHeight);

        ctx.fillStyle = "#2c3e50";
        ctx.font = "16px 'Courier New'"; // Font monospaziato
        ctx.textAlign = "left";
        
        q.code.forEach((line, index) => {
            ctx.fillText(line, 170, currentY + 25 + (index * 25));
        });
        currentY += boxHeight + 30;
    } else {
        currentY += 20;
    }

    // Disegno Opzioni (Griglia 2x2)
    const btnWidth = 300;
    const btnHeight = 60;
    const gap = 20;
    
    // Posizioni: 
    // Opzione 0: top-left, 1: top-right, 2: bot-left, 3: bot-right relative to center
    const startX = (canvas.width - (btnWidth * 2 + gap)) / 2;
    
    q.options.forEach((opt, idx) => {
        let bx = startX + (idx % 2) * (btnWidth + gap);
        let by = currentY + Math.floor(idx / 2) * (btnHeight + gap);
        
        let btn = drawButton(bx, by, btnWidth, btnHeight, opt, "#3498db");
        buttons.push({area: btn, action: 'ANSWER', value: idx});
    });
}

function drawFeedbackScreen() {
    // Disegniamo sopra la schermata corrente con una overlay
    ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
    ctx.fillRect(50, 100, 700, 400);
    ctx.strokeStyle = isCorrect ? "#27ae60" : "#c0392b";
    ctx.lineWidth = 5;
    ctx.strokeRect(50, 100, 700, 400);

    ctx.textAlign = "center";
    ctx.font = "bold 36px 'Segoe UI'";
    ctx.fillStyle = isCorrect ? "#27ae60" : "#c0392b";
    ctx.fillText(isCorrect ? "Corretto!" : "Sbagliato", canvas.width/2, 200);

    ctx.font = "20px 'Segoe UI'";
    ctx.fillStyle = "#333";
    wrapText(ctx, feedbackMessage, canvas.width/2, 260, 600, 30);

    buttons = [];
    let btn = drawButton(canvas.width/2 - 100, 400, 200, 50, "Avanti >>", "#34495e");
    buttons.push({area: btn, action: 'NEXT'});
}

// Utility per testo a capo
function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    
    for(let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = context.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
            context.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else {
            line = testLine;
        }
    }
    context.fillText(line, x, y);
}

// Gestione Click
canvas.addEventListener('click', function(evt) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = evt.clientX - rect.left;
    const mouseY = evt.clientY - rect.top;

    // Controllo se un pulsante è stato cliccato
    for(let b of buttons) {
        if(mouseX >= b.area.x && mouseX <= b.area.x + b.area.w &&
           mouseY >= b.area.y && mouseY <= b.area.y + b.area.h) {
            
            handleAction(b.action, b.value);
            break;
        }
    }
});

function handleAction(action, value) {
    if (action === 'START') {
        score = 0;
        currentQuestionIndex = 0;
        currentState = STATE_QUESTION;
        drawQuestionScreen();
    } 
    else if (action === 'ANSWER') {
        const q = questions[currentQuestionIndex];
        if (value === q.correct) {
            score++;
            isCorrect = true;
            feedbackMessage = q.explanation;
        } else {
            isCorrect = false;
            feedbackMessage = "Errato. " + q.explanation;
        }
        currentState = STATE_FEEDBACK;
        drawFeedbackScreen();
    }
    else if (action === 'NEXT') {
        currentQuestionIndex++;
        if (currentQuestionIndex < questions.length) {
            currentState = STATE_QUESTION;
            drawQuestionScreen();
        } else {
            currentState = STATE_END;
            drawEndScreen();
        }
    }
    else if (action === 'RESTART') {
        score = 0;
        currentQuestionIndex = 0;
        currentState = STATE_START;
        drawStartScreen();
    }
}

// Avvio iniziale
drawStartScreen();

</script>
</body>
</html>
